У циклов есть две важных фишечки:
1. Оператор continue
2. Оператор breake

Мы может прервать тело цикла в любой удобный момент оператором continue
Также мы может полностью остановить цикл оператором breake

Чтобы показать реальную пользу continue и break, заглянем в будущее
Мариночка рассталась с парнем, и теперь ей нужно поднять свой алений хоровод и оперативно найти замену
Марина - женщина прогрессивная и в случайности не верит, поэтому она обратилась за помощью к местному нумерологу 
Нумеролог на основе анализа ее имени и даты рождения сказал выдал следующие рекомендации:
- в имени мужчины должно быть более пяти букв, иначе личная жизнь с ним не сложится
- сумма индексов букв имени должна составлять счастливое число, которое определяется как день рождения мариночки минус сегодняшнее число (очевидно, что по модулую)
Короче, нам безразличен этот бред, к тому же мариночка не знает что такое модуль числа (не будьте как мариночка), поэтому она просто наугад придумывает числа 
В программе есть константа - 6, переменная num которую вводит пользователь, слайс с именами

Оператор continue прерывает тело цикла, если в имени меньше букв, чем в константе minLetter
Если найдено первое совпадение, то цикл заканчивается
Если мы дошли до последнего имени, но цикл не прервался - значит ничего не найдено


////////////////


func main() {
	const minLetter = 6

	var num int

	fmt.Println("Введите сумму")
	fmt.Scan(&num)

	names := []string{"Тимур", "Вазген", "Виталий", "Бахтияр", "Пахлавон"}

	for index, value := range names {

		if(len(value) < minLetter) {
			continue
		}

		sum := countLetters(len([]rune(value)))

		if sum == num {
			fmt.Printf("Кандидат найден, это %v\n", value)
			break
		}

		if index == len(names) - 1 {
			fmt.Printf("Увы, но звезды не сошлись\n")
		}

	}
}

func countLetters(num int) int {
	result := 0

	for i := 0; i <= num; i++ {
		result += i
	}

	return result
}

////////////////
