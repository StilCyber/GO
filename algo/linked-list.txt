************************************************************************
Связные списки

В рантайме составные типы данных (всякие там массивы и др.) хранятся в так называемой куче 
Куча - относительно упорядоченная помойка из ячеек памяти (крыс только не хватает)
Представьте себе большую таблицу с множеством клеток, где у каждой клетки есть свой адрес 
Вот, это и есть куча 

В куче можно хранить данные разными способами 
Массивы - это всегда последовательность ячеек - к примеру, ячейки со второй по десятую 
Если вдруг мы хотим добавить элемент в массив, а так закончилось место
   то происходит копирование всего массива и перенос его туда, где не будет тесно 
Соответственно, мы может очень просто найти элемент массива, но как-то его изменить уже трудозатратно 
Когда мы удалаем элемент внутри массива, нужно сдвигать другие ячейки и др. потому что 
   расположение массива всегда непрерывно 

А что если мы будем тупо искать свободные ячейки в куче и запихивать туда данные? 
Нам не нужно будет искать свободную последовательность ячеек 
Такой структурой и является связный список 
Связный список состоит из узлов (ноды)
Каждый узел содержит в себе значение + ссылку на следующую ноду 

 type ListNode struct {
    Val int
    Next *ListNode
}

То есть как это выглядит 
Есть чокнутая клиника где 100 окошек регистратуры 
Вы знаете, что нужный вам талон дают в окне 2
Идете в окно 2, вам говорят окей, но нужна еще бумажка,
   которую можно взять в окне 88 

Такой список называется односвязным
Если есть еще и указание на предыдущую ноду - то это двусвязный список 

Схематично односвязный список выглядит вот так:

1 => 2 => 3 => 4 => 5 

Первый элемент называется head 
Второй элемент обделили специальным названием, но опознать его несложно
В нем ссылка на следующую ноду - это nil 

/* Задача 1
Remove Nth Node From End of List
*/
Рассмотрим одну из самых известных задача на связные списки 
Суть задачи - удалить один из узлов линкед листа

Описание:
leetcode.com/problems/remove-nth-node-from-end-of-list/description

Особенность таких задач - мы не видим сразу всего исходного набора входных данных 
На вход подается ссылка на структуру head:
 type ListNode struct {
    Val int
    Next *ListNode
}

Посмотрим на саму запись:
Input: head = [1,2,3,4,5], n = 2

Вот этот массив - [1,2,3,4,5] это не значения нод Value, это просто их порядоковые номера
В самой структуре узла они не отображаются, т.е. сделано просто для удобства 
Здесь нам нужно удалить вторую ноду с конца - это нода 4 
Как это сделать? Нужно найти узел 3 
В этом узле есть Value и ссылка на ноду 4
Нужно перетереть эту ссылку, чтобы она указывала на ноду 5

Есть вот так:
1 => 2 => 3 => 4 => 5 

А нам нужно сделать вот такой порядок:
1 => 2 => 3 => 5 

Для решения удобно использовать фейковую ноду - dummyNode


func removeNthFromEnd(head *ListNode, n int) *ListNode {
    // фейковая нода 
    dummyNode := &ListNode{Val: 0, Next: head}

    // определение длины списка
    length := 0
    currNode := dummyNode

    for currNode.Next != nil {
        currNode = currNode.Next
        length++
    }

    // доходим до искомого узла перед удаляемой нодой
    currNode = dummyNode 

    for i := 0; i <= (length - n - 1); i++ {
        currNode = currNode.Next
    }

    // и перетираем ссылку на следующий элемент
    currNode.Next = currNode.Next.Next

    return dummyNode.Next
}

Итак, вначале создаем фейковую ноду, которую помещает в самое начало линкед листа:
dummyNode := &ListNode{Val: 0, Next: head}

Обратите внимание, что значением поля Next является указатель на структуру первой ноды 

Затем, нам нужно определить длину списка 
Делается это достаточно просто - заводим счетчик, length, и инкрементируем его до тех пор,
   пока не наткнемся на последнюю ноду 

После этого, бежим циклом до той ноды, у которой нужно перетереть указатель
Она имеет вот такое местоположение:
length - n - 1

И, наконец, перетираем поле Next 

Здесь можно задаться вопросом - на кой вообще сдалась фейковая нода, 
  если вот для такого кейса Input: head = [1,2,3,4,5], n = 2 
  можно написать без нее 

Нюанс в том, что если у нас только один узел - [1], то нужно либо писать отдельную логику для этого кейса,
   либо заводить фейковый узел
dummyNode решает проблему, когда нужно удалить первый элемент списка

Возьмите на заметку: чтобы добраться до нужного узла у нас линейная сложность, нужно идти с начала списка
Но, чтобы внести изменение, перетерев указатель, то это константное время 
В массивах все с точностью наоборот 

И кстати, перетерли мы указатель, что происходит с удаленной нодой?
Ее значение остается в куче, но соответствующие ячейки помечаются как свободные для использования 
Т.е. фактического удаления данных не происходит - они перезатрутся, когда понадобятся этой же или другой программе
А до тех пор будут пока еще находиться в памяти
Кто смотрел школу тюрьму поймет о чем я 

Рассмотрим еще один способ решения задачи
Он более... солидный, что-ли 
Через быстрый и медленный указатели 

func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dummyNode := &ListNode{Val: 0, Next: head}

    fast := dummyNode

    for i := 0; i < (n + 1); i++ {
        fast = fast.Next
    }

    slow := dummyNode

    for fast != nil {
        fast = fast.Next
        slow = slow.Next
    }

    slow.Next = slow.Next.Next

    return dummyNode.Next
}


               f
0 => 1 => 2 => 3 => 4 => 5 
s

Устанавливаем два указателя - быстрый (n + 1), добавляем единицу потому что создали фейковую ноду 
И начинам в цикле сдвигать оба из них
Когда быстрый указатель дойдет до конца списка,
   то медленный указатель будет указывать на ноду, в которой нужно перетереть указатель 

Сложность:
time - O(n)
mem - O(1)

/* Задача 2
Reverse Linked List
*/

Описание:
leetcode.com/problems/reverse-linked-list/description/

Выглядит проще предыдущей, не так ли:

Есть такое:
1 => 2 => 3 => 4 => 5 

Нужно сделать вот так:
5 => 4 => 3 => 2 => 1 

func reverseList(head *ListNode) *ListNode {
    var prev *ListNode
    curr := head

    for curr != nil {
        tmp := curr
        curr = curr.Next
        tmp.Next = prev
        prev = tmp
    }

    return prev
}

Оперировать будем двумя нодами - текущей и предыдущей
В качестве текущей ноды начинаем, само собой, с head
curr := head

Для предыдущей ноды создаем ниловую структуру
var prev *ListNode
Важно делать именно так, т.к. пустая структура будет добавлять лишний ноль в конце output 

Когда бежим циклом по нодам, понадобится временная переменная для каждой итерации
Здесь главное - порядок 
Не забывайте, что мы работает с указателями
Действия:
1. Присвоить указатель на текущую ноду временной переменной
   tmp := curr
2. Заменить текущий элемент указателем на следующую ноду
   curr = curr.Next
3. Поменять ссылку во временной передменной на предыдущую ноду
4. Присвоить значение временной переменной предыдущей ноде

Сложность:
time - O(n)
mem - O(1)

/* Задача 3
Convert Binary Number in a Linked List to Integer
*/

Задача элементарная, но есть своя сложность - это, кхм, не сам линкед лист, а особенности конвертации данных

Описание:
leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/description

Подсказка: можно заюзать strconv.ParseInt

Сложность:
time - O(n)
mem - O(1)

/* Задача 4
Middle of the Linked List
*/

Нужно найти середину списка
Если список имеет нечетную длину - то прям реально середину (если, к примеру, 5 нод, то нужна нода 3)
Если длина четная - возвращаем начало второй половины списка (если 6 нод, возвращаем 4 ноду)

Задача решается через два указателя - быстрый и медленный
Изначально fast и slow указатели ставятся на первую ноду 
Затем, перешагиваем быстрым указателем на две ноды вперед, 
     а медленным указателем - на одну ноду 

f
1 => 2 => 3 => 4 => 5 
s

          f
1 => 2 => 3 => 4 => 5 
     s

                    f
1 => 2 => 3 => 4 => 5 
          s

Такиим образом, нам нужна нода, на которую по итогу будет указывать медленный указатель

Описание:
leetcode.com/problems/middle-of-the-linked-list/description

func middleNode(head *ListNode) *ListNode {
    fast := head
    slow := head

    for fast != nil && fast.Next != nil {
        fast = fast.Next.Next
        slow = slow.Next
    }

    return slow
}

Здесь обратите внимание на условие цикла
fast != nil && fast.Next != nil
Только такой вариант будет корректно работать в гошке из-за особенностей nil 

Сложность:
time - O(n)
mem - O(1)

/* Задача 5
Palindrome Linked List
*/

Достаточно известная задача (кхм, в узких алгоритмических кругах)
Непростая, и состоит фактически из трех задач
Нужно найти срединную ноду, развернуть вторую часть списка, пробежаться двумя указателями и сравнить

Описание:
leetcode.com/problems/palindrome-linked-list/description


func isPalindrome(head *ListNode) bool {
    middleNode := findMiddleNode(head)
    reverseNode := reverseList(middleNode)

    p1 := head
    p2 := reverseNode

    for p1 != nil && p2 != nil {
        if p1.Val != p2.Val {
            return false
        }

        p1 = p1.Next
        p2 = p2.Next
    }

    return true
    
}

func findMiddleNode(head *ListNode) *ListNode {
    slow := head
    fast := head

    for fast != nil && fast.Next != nil {
        fast = fast.Next.Next
        slow = slow.Next
    }

    return slow
}

func reverseList(head *ListNode) *ListNode {
    var prev *ListNode
    curr := head

    for curr != nil {
        tmp := curr 
        curr = curr.Next
        tmp.Next = prev
        prev = tmp
    }

    return prev
}

Сложность:
time - O(n)
mem - O(1)