************************************************************************
Паттер хэш-мапы 

Хэш-мапа - структура данных, где инфа хранится в формате ключ-значение
Поддерживает три операции, которые выполняются в среднем за константное время:
1. Insert - O(1)
2. Find - O(1)
3. Delete - O(1)

При обработке ключа хэш-функцией генериуется значение, которое указывает на 
    конкретный бакет и место элемента в нем 

Операции выполняются "в среднем" за константное время,
   т.е. мы, как правило, сразу же находит нужный ключ без перебора значений
Если образуются коллизии (для разных ключей определятся одно и то же место), 
   то эта проблема решается связной цепочкой значений, 
   для поиска по которой нужно проитерироваться по ней 

Преимущество использовать хэш-таблиц: 
Доступ к данным за константное время

Недостаток хэш-таблиц:
Требуется выделение дополнительной памяти

/* Задача 1
Two sum
*/

Описание:
https://leetcode.com/problems/two-sum/description/

На вход подается слайс типа int и число target (тоже int)
Слайс неотсортирован
Input: nums = [2,7,11,15], target = 9

Нужно найти в слайсе два числа, которые в сумме дают 9 
В данном случае это числа 2 и 7

Результатом должен стать слайс с индексами этих чисел
Output: [0,1]

Индексы можно располагать в любом порядке
В этом исполнении задачи в слайсе всегда есть два нужных числа 

Решение задачи через мапы сводится к следующему:
1. Бежим циклом по слайсу 
2. Для каждого элемента высчитываем дополнение
   Дополнение - то число, которого не хватает до числа target 
3. Если дополнение есть в мапе - завершаем функцию, если нет - добавляет число в мапу 

В мапе ключ - это сам элемент, значение - его индекс 

Так, в начале цикла идет 2
Высчитываем дополнение: 9 - 2 = 7
Нам нужна семерка 
Мы не находим в мапе ключа 7 
   ... и добавляем запись в мапу: mapa[2] = 0

Дальше мы доходим до числа 7
Дополнение для него - 2
Двойка есть в мапе
Это то, что нам нужно

func twoSum(nums []int, target int) []int {
 
 mapa := make(map[int]int, len(nums))

 for index, value := range nums {
    add := target - value
    if _, ok := mapa[add]; ok {
        return []int{index, mapa[add]}
    } else {
        mapa[value] = index
    }
 }

 return []int{}
}

Решение:
   Бежим циклом по слайсу
   Для каждого элемента высчитываем дополнение 
   Если дополнение есть в мапе - возвращаем индексы дополнения и текущего элемента 
   Как только нашли дополнение - выходим из цикла 

Сложность:
time - O(n)
mem - O(n)

По времени - линейная сложность - в худшем случае мы дойдем до последнего элемента слайса, 
    т.е. переберем все элементы 

По памяти - создание мапы требует выделения дополнительной памяти
   Количество пар ключ-значение максимум может равняться числу элементов слайса 
   Поэтому сложность тоже линейная 

Если мы решали задачу через вложенные циклы, то сложность была бы такой
time - O(n*2)
mem - O(1)

По времени - квадратичная сложность, т.к. вложенные циклы 
По памяти - константная, т.к. доп. памяти выделять не нужно 

Как выбрать, какой вариант использовать?
Узнать у собеседующего про условия - можно ли использовать доп.память

Обратите внимание - чтобы не использовать дополнительную память, мы не создаем отдельную переменную для результата
При таком варианте функция займет 5.81 MB в памяти

А вот при таком варианте с заведением переменной памяти займет 5.87 MB

func twoSum(nums []int, target int) []int {
    
    result := make([]int, 0, 2)

    mapa := make(map[int]int, len(nums))

    for index, value := range nums {
        add := target - value
        if _, ok := mapa[add]; ok {
            result = append(result, index, mapa[add])
            break
        } else {
            mapa[value] = index
        }
    }

    return result
}

Есть еще один способ решения этой задачи - через два указателя
Но, для этого нужно вначале отсортировать массив

/* Задача 2
Majority Element
*/

Описание:
https://leetcode.com/problems/majority-element/description/

Несложная задача 
Решить можно с использованием сортировки, но лучше через мапу - на собесах здесь на сортировку будут агриться

/* Задача 3
Contains Duplicate
*/

Простая и часто встречающаяся задачка

Описание:
https://leetcode.com/problems/contains-duplicate/description/

/* Задача 4
Valid Sudoku
*/

Задача medium уровня 

Описание:
https://leetcode.com/problems/valid-sudoku/description/

У нас есть судоку 
Нужно проверить, правильно ли он заполнен 
Судоку может быть или полностью заполнен, или частично 

Интересно, есть ли алгосы на японские кроссворды...

Есть три правила:
1. Числа в ряду не должны повторяться
2. Числа в колонке не должны повторяться
3. Числа в блоках не должны повторяться
   Блок - квадрат три на три, таких всего девять 

На вход дается двумерный массив [][]byte 
Ожидаемый результат - true или false 

func isValidSudoku(board [][]byte) bool {
    rowsMap := make(map[int]map[byte]bool)
    columnsMap := make(map[int]map[byte]bool)
    blocksMap := make(map[int]map[byte]bool)

    for i := range board {
        for j, value := range board[i] {
            if value == '.' {
                continue
            }

            blockIndex := j/3 + i/3 * 3

            if rowsMap[i] == nil {
                rowsMap[i] = make(map[byte]bool)
            }

            if columnsMap[j] == nil {
                columnsMap[j] = make(map[byte]bool)
            }

            if blocksMap[blockIndex] == nil {
                blocksMap[blockIndex] = make(map[byte]bool)
            }

            if rowsMap[i][value] || columnsMap[j][value] || blocksMap[blockIndex][value] {
                return false
            }

            rowsMap[i][value], columnsMap[j][value], blocksMap[blockIndex][value] = true, true, true
        }
    }

    return true
}

Идем по порядку
Здесь нам нужно завести три отдельные мапы - для строк, колонок и чисел 
Окей, но нам там нужно хранить само число (точнее байты) и булево значение - встречалось оно там уже или нет
Для этого в качестве значений трех мап выступают... другие мапы 
Итого мы оперируем 27-ю мапами (!)

На вход подается двумерный массив, поэтому нужно пробежаться вложенными циклами 
Для каждого элемента вложенного цикла определяет, является ли он '.' - тогда пропускаем и идет дальше 

Дальше - самая интересная часть, нужно определить расположение значения в блоке 
Делается это вот по такой нехитрой формуле:
j/3 + i/3 * 3

Потом мы вспоминаем, что попытка доступа к ниловой мапе приводит к панике в рантайме
И для этого вешаем проверки 

И затем совсем просто - если значение уже встречалось в строке, колонке или в блоке - возвращаем false 
Если все в порядке - заносим значение во все три мапы, где ключ мапы - наше число (байтики), value ключа - true 

Кстати, если в мапе значением ключа выступает булево значение - это по сути вещей структура Set
       т.е. коллекция уникальных значений 



