************************************************************************
Паттер хэш-мапы 

Хэш-мапа - структура данных, где инфа хранится в формате ключ-значение
Поддерживает три операции, которые выполняются в среднем за константное время:
1. Insert - O(1)
2. Find - O(1)
3. Delete - O(1)

При обработке ключа хэш-функцией генериуется значение, которое указывает на 
    конкретный бакет и место элемента в нем 

Операции выполняются "в среднем" за константное время,
   т.е. мы, как правило, сразу же находит нужный ключ без перебора значений
Если образуются коллизии (для разных ключей определятся одно и то же место), 
   то эта проблема решается связной цепочкой значений, 
   для поиска по которой нужно проитерироваться по ней 

Преимущество использовать хэш-таблиц: 
Доступ к данным за константное время

Недостаток хэш-таблиц:
Требуется выделение дополнительной памяти

/* Задача 1
Two sum
*/

Описание:
https://leetcode.com/problems/two-sum/description/

На вход подается слайс типа int и число target (тоже int)
Слайс неотсортирован
Input: nums = [2,7,11,15], target = 9

Нужно найти в слайсе два числа, которые в сумме дают 9 
В данном случае это числа 2 и 7

Результатом должен стать слайс с индексами этих чисел
Output: [0,1]

Индексы можно располагать в любом порядке
В этом исполнении задачи в слайсе всегда есть два нужных числа 

Решение задачи через мапы сводится к следующему:
1. Бежим циклом по слайсу 
2. Для каждого элемента высчитываем дополнение
   Дополнение - то число, которого не хватает до числа target 
3. Если дополнение есть в мапе - завершаем функцию, если нет - добавляет число в мапу 

В мапе ключ - это сам элемент, значение - его индекс 

Так, в начале цикла идет 2
Высчитываем дополнение: 9 - 2 = 7
Нам нужна семерка 
Мы не находим в мапе ключа 7 
   ... и добавляем запись в мапу: mapa[2] = 0

Дальше мы доходим до числа 7
Дополнение для него - 2
Двойка есть в мапе
Это то, что нам нужно

func twoSum(nums []int, target int) []int {
 
 mapa := make(map[int]int, len(nums))

 for index, value := range nums {
    add := target - value
    if _, ok := mapa[add]; ok {
        return []int{index, mapa[add]}
    } else {
        mapa[value] = index
    }
 }

 return []int{}
}

Решение:
   Бежим циклом по слайсу
   Для каждого элемента высчитываем дополнение 
   Если дополнение есть в мапе - возвращаем индексы дополнения и текущего элемента 
   Как только нашли дополнение - выходим из цикла 

Сложность:
time - O(n)
mem - O(n)

По времени - линейная сложность - в худшем случае мы дойдем до последнего элемента слайса, 
    т.е. переберем все элементы 

По памяти - создание мапы требует выделения дополнительной памяти
   Количество пар ключ-значение максимум может равняться числу элементов слайса 
   Поэтому сложность тоже линейная 

Если мы решали задачу через вложенные циклы, то сложность была бы такой
time - O(n*2)
mem - O(1)

По времени - квадратичная сложность, т.к. вложенные циклы 
По памяти - константная, т.к. доп. памяти выделять не нужно 

Как выбрать, какой вариант использовать?
Узнать у собеседующего про условия - можно ли использовать доп.память

Обратите внимание - чтобы не использовать дополнительную память, мы не создаем отдельную переменную для результата
При таком варианте функция займет 5.81 MB в памяти

А вот при таком варианте с заведением переменной памяти займет 5.87 MB

func twoSum(nums []int, target int) []int {
    
    result := make([]int, 0, 2)

    mapa := make(map[int]int, len(nums))

    for index, value := range nums {
        add := target - value
        if _, ok := mapa[add]; ok {
            result = append(result, index, mapa[add])
            break
        } else {
            mapa[value] = index
        }
    }

    return result
}

Есть еще один способ решения этой задачи - через два указателя
Но, для этого нужно вначале отсортировать массив