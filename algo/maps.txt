************************************************************************
Паттер хэш-мапы 

Хэш-мапа - структура данных, где инфа хранится в формате ключ-значение
Поддерживает три операции, которые выполняются в среднем за константное время:
1. Insert - O(1)
2. Find - O(1)
3. Delete - O(1)

При обработке ключа хэш-функцией генериуется значение, которое указывает на 
    конкретный бакет и место элемента в нем 

Операции выполняются "в среднем" за константное время,
   т.е. мы, как правило, сразу же находит нужный ключ без перебора значений
Если образуются коллизии (для разных ключей определятся одно и то же место), 
   то эта проблема решается связной цепочкой значений, 
   для поиска по которой нужно проитерироваться по ней 

Преимущество использовать хэш-таблиц: 
Доступ к данным за константное время

Недостаток хэш-таблиц:
Требуется выделение дополнительной памяти

/* Задача 1
Two sum
*/

Описание:
leetcode.com/problems/two-sum/description/

На вход подается слайс типа int и число target (тоже int)
Слайс неотсортирован
Input: nums = [2,7,11,15], target = 9

Нужно найти в слайсе два числа, которые в сумме дают 9 
В данном случае это числа 2 и 7

Результатом должен стать слайс с индексами этих чисел
Output: [0,1]

Индексы можно располагать в любом порядке
В этом исполнении задачи в слайсе всегда есть два нужных числа 

Решение задачи через мапы сводится к следующему:
1. Бежим циклом по слайсу 
2. Для каждого элемента высчитываем дополнение
   Дополнение - то число, которого не хватает до числа target 
3. Если дополнение есть в мапе - завершаем функцию, если нет - добавляет число в мапу 

В мапе ключ - это сам элемент, значение - его индекс 

Так, в начале цикла идет 2
Высчитываем дополнение: 9 - 2 = 7
Нам нужна семерка 
Мы не находим в мапе ключа 7 
   ... и добавляем запись в мапу: mapa[2] = 0

Дальше мы доходим до числа 7
Дополнение для него - 2
Двойка есть в мапе
Это то, что нам нужно

func twoSum(nums []int, target int) []int {
 
 mapa := make(map[int]int, len(nums))

 for index, value := range nums {
    add := target - value
    if _, ok := mapa[add]; ok {
        return []int{index, mapa[add]}
    } else {
        mapa[value] = index
    }
 }

 return []int{}
}

Решение:
   Бежим циклом по слайсу
   Для каждого элемента высчитываем дополнение 
   Если дополнение есть в мапе - возвращаем индексы дополнения и текущего элемента 
   Как только нашли дополнение - выходим из цикла 

Сложность:
time - O(n)
mem - O(n)

По времени - линейная сложность - в худшем случае мы дойдем до последнего элемента слайса, 
    т.е. переберем все элементы 

По памяти - создание мапы требует выделения дополнительной памяти
   Количество пар ключ-значение максимум может равняться числу элементов слайса 
   Поэтому сложность тоже линейная 

Если мы решали задачу через вложенные циклы, то сложность была бы такой
time - O(n*2)
mem - O(1)

По времени - квадратичная сложность, т.к. вложенные циклы 
По памяти - константная, т.к. доп. памяти выделять не нужно 

Как выбрать, какой вариант использовать?
Узнать у собеседующего про условия - можно ли использовать доп.память

Обратите внимание - чтобы не использовать дополнительную память, мы не создаем отдельную переменную для результата
При таком варианте функция займет 5.81 MB в памяти

А вот при таком варианте с заведением переменной памяти займет 5.87 MB

func twoSum(nums []int, target int) []int {
    
    result := make([]int, 0, 2)

    mapa := make(map[int]int, len(nums))

    for index, value := range nums {
        add := target - value
        if _, ok := mapa[add]; ok {
            result = append(result, index, mapa[add])
            break
        } else {
            mapa[value] = index
        }
    }

    return result
}

Есть еще один способ решения этой задачи - через два указателя
Но, для этого нужно вначале отсортировать массив

/* Задача 2
Majority Element
*/

Описание:
leetcode.com/problems/majority-element/description/

Несложная задача 
Решить можно с использованием сортировки, но лучше через мапу - на собесах здесь на сортировку будут агриться

/* Задача 3
Contains Duplicate
*/

Простая и часто встречающаяся задачка

Описание:
leetcode.com/problems/contains-duplicate/description/

/* Задача 4
Valid Sudoku
*/

Задача medium уровня 

Описание:
leetcode.com/problems/valid-sudoku/description/

У нас есть судоку 
Нужно проверить, правильно ли он заполнен 
Судоку может быть или полностью заполнен, или частично 

Интересно, есть ли алгосы на японские кроссворды...

Есть три правила:
1. Числа в ряду не должны повторяться
2. Числа в колонке не должны повторяться
3. Числа в блоках не должны повторяться
   Блок - квадрат три на три, таких всего девять 

На вход дается двумерный массив [][]byte 
Ожидаемый результат - true или false 

func isValidSudoku(board [][]byte) bool {
    rowsMap := make(map[int]map[byte]bool)
    columnsMap := make(map[int]map[byte]bool)
    blocksMap := make(map[int]map[byte]bool)

    for i := range board {
        for j, value := range board[i] {
            if value == '.' {
                continue
            }

            blockIndex := j/3 + i/3 * 3

            if rowsMap[i] == nil {
                rowsMap[i] = make(map[byte]bool)
            }

            if columnsMap[j] == nil {
                columnsMap[j] = make(map[byte]bool)
            }

            if blocksMap[blockIndex] == nil {
                blocksMap[blockIndex] = make(map[byte]bool)
            }

            if rowsMap[i][value] || columnsMap[j][value] || blocksMap[blockIndex][value] {
                return false
            }

            rowsMap[i][value], columnsMap[j][value], blocksMap[blockIndex][value] = true, true, true
        }
    }

    return true
}

Идем по порядку
Здесь нам нужно завести три отдельные мапы - для строк, колонок и чисел 
Окей, но нам там нужно хранить само число (точнее байты) и булево значение - встречалось оно там уже или нет
Для этого в качестве значений трех мап выступают... другие мапы 
Итого мы оперируем 27-ю мапами (!)

На вход подается двумерный массив, поэтому нужно пробежаться вложенными циклами 
Для каждого элемента вложенного цикла определяет, является ли он '.' - тогда пропускаем и идет дальше 

Дальше - самая интересная часть, нужно определить расположение значения в блоке 
Делается это вот по такой нехитрой формуле:
j/3 + i/3 * 3

Потом мы вспоминаем, что попытка доступа к ниловой мапе приводит к панике в рантайме
И для этого вешаем проверки 

И затем совсем просто - если значение уже встречалось в строке, колонке или в блоке - возвращаем false 
Если все в порядке - заносим значение во все три мапы, где ключ мапы - наше число (байтики), value ключа - true 

Кстати, если в мапе значением ключа выступает булево значение - это по сути вещей структура Set
       т.е. коллекция уникальных значений 

Сложность:
time - O(n*2)
mem - O(n)

/* Задача 5
Isomorphic Strings
*/

Изоморфизм - однозначное соответствие между элементами двух групп 
В данном случае - между символами двух строк 

Описание:
leetcode.com/problems/isomorphic-strings/description

Рассмотрим подробнее

s = "egg", t = "add"

Берем два элемента из разных строк по одному идексу 
Первая такая связка устанавливает строгое соответствие
Сначала образуется пара e - a
Затем пара g - d 
Других соотношений быть не может 
К примеру, если бы у нас возникло соотношение e -j, то изоморфизм здесь был бы нарушен 
s = "egge", t = "addj"

Как быть, если символы тождественны?
s = "abc", t = "aba"

Здесь изоморфизма нет, т.к. a - a изначально составляет пару, которая потом нарушается 

func isIsomorphic(s string, t string) bool {
    sMapa, tMapa := make(map[byte]byte), make(map[byte]byte)

    for i := range s {
        if value, ok := sMapa[s[i]]; ok && value != t[i] {
            return false
        }

        if value, ok := tMapa[t[i]]; ok && value != s[i] {
            return false
        }

        sMapa[s[i]] = t[i]
        tMapa[t[i]] = s[i]
    }

    return true
}

Ход решения:
1. Создаем две мапы - одна для s - t, другая для t - s 
2. Идет циклом по любой из строк 
3. Вешаем проверки - если в каждой из мап есть текущий элемент и он не равен элементу из второй строки - возвращаем false
4. Добавляем данные в мапы 

Сложность:
time - O(n)
mem - O(n)

/* Задача 6
Maximum Number of Balloons
*/

Странновато выглядит, но давайте попробуем

Описание:
leetcode.com/problems/maximum-number-of-balloons/description

Hint: при решении можно использовать вот такую мапу 

mapa := map[string]float64{
        "b": 0, 
        "a": 0,
        "l": 0,
        "o": 0,
        "n": 0,
    }



/* Задача 7
Unique Number of Occurrences
*/

Действительно хорошая задачка
Вначале подсчитываем число вхождений каждой цифры в слайсе
И затем решение сводится к поиску дубликатов

Описание:
leetcode.com/problems/unique-number-of-occurrences/description

Hint: проверку дубликатов в мапе можно делать двумя способами
1. Через заведение нового слайса 
2. Через вторую мапу, которая будет играть роль set (коллекции уникальных значений)
Крайне рекомендуется решить через set - map[int]bool

/* Задача 7
Find Words That Can Be Formed by Characters
*/

Норм задача, много мелких нюансов, просто нужно понять в какое место воткнуть мапу

Описание:
leetcode.com/problems/find-words-that-can-be-formed-by-characters/description


/* Задача 8
Find Lucky Integer in an Array
*/

Прикольная несложная задачка, самое то чтобы расслабиться

Описание:
leetcode.com/problems/find-lucky-integer-in-an-array/description

/* Задача 9
Destination City
*/

Реально классная задача, решайте с удовольствием (^_^)

Описание:
leetcode.com/problems/destination-city/description


/* Задача 10
Find Winner on a Tic Tac Toe Game
*/

Финальная задача 
Помните крестики-нолики? Ха-ха

Описание:
leetcode.com/problems/find-winner-on-a-tic-tac-toe-game/description

