Структуры предоставляют возможность по созданию объектов - а именно объектов структуры 
Объект структуры - совокупность полей типа ключ - значение 
Также у структуры могут быть методы 
Метод - функция, которая в качестве первого аргумента принимает объект структуры (или указатель него него)
Метод описывается вне структуры 

//////////////

type Data struct {
    Id number
}

func (d *Data) Print() {
    fmt.Println(Data.id)
}

/////////////
(d *Data) - называется ресивером
Ресивер - синтаксический сахар 
Компилятор возьмет *Data и засунет его первым аргументом в функцию Print

Как и во всех остальных случаев передачи указателя на структуру аргментом функции - ее разыменовывать не нужно (комплилятор сделает это за нас)
Если мы передаем не указатель, а саму структуру, то она полностью копируется, и изменение полей структуры внутри метода не повличет изменения оригинального объекта 

Собственно, использовать указатель целесообразно в следующих случаях:
1. Нужно изменить объект структуры (получатель)
2. Объект слишком большого размера 
3. Есть поля, которые нельзя копировать (к примеру, типы из пакета sync)

В некоторых случаях получатель должен быть значением:
1. Недопустить изменение объекта-получателя
2. Получатель - базовый тип (int, string, float64 и др.) 
3. Если изменяемые поля находятся внутри другой структуры
Последний пример относится к композиции - если у нас есть вложенная структура, и нужна только она для изменения ее полей,
   то мы все равно перекопируем указатель 

**************
Как определить порядок полей в структуре?
1. Читаемость кода 
2. Выравнивание по памяти
3. Сравнение структур 

Если при выравнивании более увесистое поле лучше поместить наверх, то если мы предполагаем в дальшем сравнение, 
   то здесь лучше мелкие поля поместить наверх, т.к. если есть разные поля то так мы может не дойти до сравнение тяжелых полей 