Примитивы синхронизации - механизмы в go, которые обеспечивают "общение" между горутинами

Data Race - несинхронное обращение разных горутин к одному и тому же участку памяти, где как минимум одна горутина
   пытается что-то записать

Race Condition - ошибка проектирвоания приложения, при которой работа системы зависит от того, 
     в каком порядке выполняются части кода

DeadLock - ситуация, когда несколько горутин ожидают ресурсов, занятых друг другом, 
   и ни одна из горутин не может продолжить выполнение
Рантайм GO определяет дедлок достаточно просто - все горутины должны находиться в статусе waiting

LiveLock - ситуация, когда система занимается бесполезной работой. 
    Приложение нигде не затревает, то нет полезных действий и состояние постоянно меняется


Опасные операции с мьютексами:

/////////

func lockAnyTimes() {
   mutex := sync.Mutex{}
   mutex.Lock()
   mutex.Lock()
}

Если нет других горутин, то будет дедлок - мьютекс должен быть освобожден

/////////

func unlockWithoutLock() {
   mutex := sync.Mutex{}
   mutex.Unlock()
}

fatal error - разблокировка незаблокированного мьютекса, приложение упадет

/////////

func unlockFromAnotherGoroutine() {
   mutex := sync.Mutex{}
   mutex.Lock()

   wg := sync.WaitGroup{}
   wg.Add(1)

   go func() {
      defer wg.Done()
      mutex.Unlock()
   }()

   wg.Wait()

   mutex.Lock()
   mutex.Unlock()
}

Мьютекс в GO не хранят индетификатор той горутины, которая их захватила - поэтому разлочить мьютекс может другая горутина


/////////

func RUnlockLockedMutex() {
   m := sync.RWMutex{}
   m.Lock()
   m.RUnlock()
}

fatal error - захватили мьютекс на операцию записи, "освободили" мьютекс на операцию чтения

Вообще, когда речь заходит про пакет sync, но лучше не делать контринтуитивных действий - это плохо заканчивается...

////////

func UnlockRLockedMutex() {
   m := sync.RWMutex{}
   m.Lock()
   m.RLock()
}

fatal error - здесь захватывается мьютекс на операции чтения и освобождается на операции записи