При работе со слайсами и массивами нужно знать ключевую особенность циклом 
Когда мы бежим циклом с использованием range, данные туда полностью копируются 

///////////////

data := [...]{1,2,3}

for value := range data {}

///////////////

При таком варианте массив просто скопируется полностью, и это внутренняя особенность языка 
Если мы работаем именно с массивом, и там достаточно много элементов
но чтобы сэкономить память лучше использовать указатель:
for value := range &data {}

Еще один вариант - взять срез на весь массив:
for value := range data[:]

Нюансы на этом не заканчиваются - когда мы берем value из range, оно как раз берется из скопированного массива (что вполне логично)
И при этом указатель для каждого value всегда будет свой (эта особенность появилась в версии языка 1.22)

///////////////

data := [...]{1,2,3}

for idx, value := range data {
    fmt.Println(&value)
    fmt.Println(&data[idx])
}

///////////////

Когда в range помещаем слайс, то копируется сама структура - указатель, длина и емкость
Однако, value в цикле все равно будет копироваться 

*********************
Отметим одну любопытную вещь - указатель на слайс и указатель на i-й его элемент это одно и то же значение 
У нас всегда есть только один указатель 
И в рантайме для определения конкретного элемента делается следующее:
1. Берется указатель на нулевой элемент массива
2. Высчитывается сдвиг - i нужно умножить на размерность типа 

К примеру, есть у нас слайс users и мы хотим взять i-й элемент:
 users[i]

В рантайме i-й элемент будет определен по следующей формуле:
*(users + i * size_type)