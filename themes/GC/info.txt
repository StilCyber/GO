Сборщик мусора - сущность в go, которая очищает из памяти объекты, которые уже не будут использоваться 
Если бы не было сборщика мусора, то наша программа постепенно забила бы всю оперативную памяти 
   и успешно бы сдохла 

Есть две основные концепции, на которых строятся сборщики мусора:
1. Трассирующие сборщики - ищут живые объекты
2. Подсчет ссылок 

Общая схема трассирующего сборщика следующая:
- останавливаются все потоки (мутаторы)
- без синхронизации обходится граф ссылок
- помечаются все используемые объекты
- непомеченные объекты удаляются 

Как внутри потока понять, что нужно остановиться?
- поместить внутрь кода условие для остановки
- использовать syscall mprotect для запрета страницы для чтения

Окей, мы остановили поток (он перешел в состояние waiting)
Теперь нужно обойти граф ссылок - это фаза mark (маркируем объекты)
Обход графа начинается со стека потоков и с глобальных переменных, формируя root set для обхода
При обходе используется алгоритм трехцветной маркировки. 
Красим граф в три цвета:
1. Черный - исследованный объект (объект посещен и все идущие из него ссылки исследованы)
2. Серый - объект ожидает исследования
3. Белый - неисследованный объект 

Есть такое правило - Tree color invariant - оно применяется здесь и означает, что 
    не бывает ссылок из черного объекта в белый

По итогу обхода графа, все белые объекты будут удалены - т.к. это те объекты, на которые никто не ссылается,
   это значит что они не нужны программе и это и есть тот самый мусор

Тогда почему три цвета, а не два? 
Связано это со способом поиска циклов в графе, чтобы не зациклиться на отдельных вершинах 

Затем есть два альтернативных варианта:
1. Sweep (подмести) - освободить то, что белого цвета 
2. Copying (перенести) - перенос живых объектов на новое место, а старое место освободить, чтобы не было фрагментации

Когда все потоки остановлены - это называется фазой STW (Stop-The-World)
Соответственно, чем больше куча, тем длиннее становятся паузы

И здесь образуется проблема, когда работа приложения, его бизнесовой логики простаивает
Решить это можно при помощи concurrent gc - запустить gc одновременно с потоками (мутаторами)
Но здесь возникает проблема потерянных объектов 
Когда возникает белый объект, на который ранее ссылался исследованный черный объект 
Способы решения проблемы last object:
1. Барьер записи - если объект черный и он начинает ссылаться на новый объект, то красится указатель на новый объект 
   сразу в серый цвет (серые объекты добавляются в очередь на обход)
2. Барьер удаления - красить объект, на который теряется ссылка, в серый цвет
   Нюанс в том, что мы может таким образом покрасить белые объекты в серый цвет, и такой объект доживет
   до следующей стадии сборки мусора
И вот, для включения и отключения барьеров требуется короткий STW

Но здесь есть еще одна проблема - если программа будет создавать столько серых объектов, что сборка мусора не будет за ней поспевать?
В таком случае нужно создавать все объекты черного цвета 

Если сборка мусора не выполняется, то не нужно мутатору оповещать поток сборщика мусора (т.е. не нужно красить в серый или в черный)

Не стоит это путать с параллельными gc - это сборка мусора со STW, но потоки работают параллельно

Теперь подробней о том как устроен gc в go
- сборщик трассирующий
- алгоритм - Mark and Sweep (тот самый трехцветный)
- конкурентный - выполняется конкурентно с основной программой с использованием барьеров записи

Фракция CPU, потребляемая воркерами gc, зафиксирована на уровне 25%
Если мусора слишком много и GC зашивается, то он может притормозить новые аллокации 
Эта оптимизация называется Mark Assist и максимальное значение потребления фракции CPU составит 30%

Когда запускается GC:
1. Превышение динамического лимита кучи (переменная GOGC)
2. ПРошло 2 минуты без GC (за это отвечает sysmon)
3. Ручной запуск runtime.GC()
   если запустить руками во время уже работающего GC, то по достижению фазы sweep он еще раз запустится

Динамический лимит - это означает, что значение переменной GOGC постоянно изменяется 
Значение берется от предыдущей кучи - по дефолту это 100%
Т.е. если у нас было занято 1 гб памяти, запустился сборщик и освободил, к примеру, 300мб,  
   то следующее значение GOGC будет браться x2 от предыдущего - уже не 1 гб, а 1.4

Здесь может возникнуть проблема
Представим, что нам доступно 10гб
Предыдущее значение GOGC 5,2гб
Следовательно, сборищик не успеет отработать, т.к. процесс при достижении лимита будет убить операционной системой (OOM killer)
Можно выставить в ручную GOGC, то это может в некоторых случаях привести к спирали смерти - death spiral:
- чаще запускам GC
- тратим больше CPU 
- пропускная способность сервиса падает
- запросы копятся в очередях
- нужно больше памяти 
Это замкнутый круг 

Решение проблемы - переменная окружения GOMEMLIMIT
Учитывая всю память потребляемую приложением (не только кучу) и ориентируясь на заданную верхнюю границу потребления памяти,
райнтайм будет чаще вызывать сборку мусора и более агрессивно возвращать память ОС

Основные фазы сборщика мусора:
1. Sweep termination:
- STW
- завершение всех sweep фаз
- удаление остатков мусора
2. Mark
- включает write barrier
- STW
- запускаем сканирование глобольных переменных и стеков (при сканировании стека, горутина останавливается)
- раскрашиваем объекты в три цвета
3. Mark termination
- STW
- дожидаемся обработки последних задач из очереди
- завершаем разметку
4. Sweep
- отключаем write barrier
- STW
- очищаем ресурсы в фоне