Ключевое слово defer позволяет отложить вызов функции 
Это бывает полезно, когда после выполнения функции нужно подчистить за собой - закрыть канал, закрыть файл и др. 

////////////////

func foo() {
    defer fmt.Println("2")
    fmt.Println("1")
}

////////////////

Когда рантайм go видит defer, то указанная после defer функция будет выполнена 
   сразу после того, как отработает return 
Поэтому, программа здесь выведет сначала 1, затем 2 

Если есть несколько defer, то они образуют стэк 
Соответственно, первый выполнится тот defer, который был положен последним 

////////////////

func bar() {
    defer fmt.Println("World")
    defer fmt.Println("Hello")
}

////////////////

Здесь вывод будет Hello World 

Идем дальше 
Аргументы функции, положенной в defer, вычисляются сразу же 

////////////////

func foo() {
    message := "привет как дела"

    defer fmt.Println(message)

    message = "Все, я передумал"
}

////////////////

Выведется "привет как дела", т.к. когда рантайм дойдет до defer он скопирует значение
   переменной message и просто пойдет дальше

А теперь немного про подставы

////////////////

func main() {
	fmt.Println("return process 1: ", process1())
	fmt.Println("return process 2: ", process2())
}

func process1() int {
	i := 0

	defer func() {
		i += 1
		fmt.Println("defer  process 1: ", i)
	}()

	return i
}

func process2() (i int) {
	i = 0

	defer func() {
		i += 1
		fmt.Println("defer  process 2: ", i)
	}()

	return i
}

////////////////

Как думаете, что выведет код?

defer  process 1:  1
return process 1:  0
defer  process 2:  1
return process 2:  1

Разрабы go предусмотрели отдельную "фичу" для именованного return 
Через defer мы может напрямую обратиться к ней, и из функции вернется уже другое значение
Сделано это в первую очередь для того, чтобы в defer можно было изменять логику по работе с ошибками 
Вот так-то вот...