Хотя удобоваримой классификации возможных типов ошибок нет, можно выделить прям такие критические ситуации, 
   когда нужно завершать программу

panic - как раз тот механизм, когда все пропало и мы полностью стопоримся 

В рантайме go выбрасывает панику каждый раз когда мы немного не правы 
При желании мы может сами создать панику вообще когда захотим 

///////////////

func main() {
	panic("Мы не правы, простите")
}

///////////////

Сигнатура паники вот такая:
func panic(v any)

Мы может скормить ей что захотим, любой интерфейс 
Паника весьма неприхотлива...

Когда случается паника, программа не просто начинает крашиться - перед этим она судорожно ищет defer 
И если в defer есть обработка паники, но можно все исправить 

Обрабатывается паника с использованием функции recover(), когда возвращает то, что было скормлено панике
recover работает исключительно в связке с defer 
Как ни странно, без отложенного вызова к панике он не приведет, но будет проигнорирован 

///////////////

func main() {
	process1()
	fmt.Println("Продолжаем как ни в чем ни бывало")
}

func process1() {
	defer func() {
		if err := recover(); err != nil {
			fmt.Println(err)
		}

	}()

	panic("Мы не правы, простите")

	fmt.Println("Мечтаем о светлом будущем")
}

///////////////

Мы не правы, простите
Продолжаем как ни в чем ни бывало

///////////////

Когда мы доходим до паники, поток останавливается и ищуются все defer 
Если паника обработана, то нам возвращаются поводья 