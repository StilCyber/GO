Горутины - это легковесные потоки
У них есть ряд особенностей:
1. context switching
Легковесный - значит, что у него есть контекст исполнения

Здесь нужно начать с потока ОС - поток это и есть контекст исполнения,
   и у одного процесса может быть множество потоков
Поток исполнения подразумевается только стеком и набором регистров 

Преимущество легковесного потока в том, что ядро о нем ничего не знает - значит, мы может на уровне приложения
   самостоятельно делать переключение контекста, для этого нужно только изменить регистры
Сами регистры пушатся на стэк и оттуда берутся

Ключевое отличие между потоком ОС и горутиной - поток ОС переключает собственно ОС

ВАЖНО: поток ОС не исполняет горутину, он делает только переключение контекста


Ключевые идеи go:
1. Не даем программисту поток ОС
2. Делаем вид, что есть только горутины
3. Механизм распределения горутин абстрагирован

2. Размер стека 
До версии go 1.4 размер стека был 8KB, затем стал 2KB

Это минимальный размер стека, он может расти 

В линуксе размер стека может быть 2,4 или 8MB

В ранних версиях go стек рос по модели segmented stack
Стек делился на сегменты, при нехвате места добавлялся еще один сегмент и обеспечивалась между ними связь (по сути связный список)
Минусы такого подхода:
- кеш-недружелюбность (могут быть прыжки по памяти)
- функция может сжирать много памяти - может потребоваться много памяти и не хватит места на стеке

Для решения этих проблем разработана модель contiguous stack
Стек растет как слайсы - места не хватает, копируем и переносим в другое место 

Максимальный размер стека зависит от архитектуры - 64-х битная - 1 гигабайт, 32-х битная - 250 мегабайт

*********************
Планировщик

Горутина может находиться в трех состояниях:
1. Running - выполняется
2. Runnable - готовая к выполнению
3. Waiting - остановлена и ждет (чего-то)


GMP модель:
1. G - Gorounite (что исполняем)
2. M - Machine (где исполняем)
3. Processor (права и ресурсы для исполнения)

P оперирует локальной очередью горутин - максимум там 256 элементов
В локальные очереди горутины поступают из глобальной очередью

Ожидающие горутины могут переходить между локальными очередями
Реализовано это по модели work stealing (другая модель обратного действия - work sharing, в go не используется)
Кража производится рандомно 
Если в другой очереди, у которой пытаемся украсть, ничего нет - переходим на следующую жертву
За раз крадется половина горутин 

Что происходит когда вызываются syscall? (в веб приложениях часто нужно сделать запрос по сети др.)
Когда производится сисколл, поток ОС блокируется 
Соответственно, блокируются и все горутины в очереди (они будут голодать), и текущая исполняемая горутина тоже

Здесь придуман механизм HANDOFF 
Создается новый поток ОС, и за ним закрепляется исполняемая горутина, которая ждет завершения системного вызова 
Затем, после того как отработает сисколл, поток освободится и попадет в Threal Poll - место, где хранятся свободные для использования потоки ОС
Поэтому, в рантайме потоков может быть больше чем значение параметра GOMAXPROCS
При этом, горутине надо будет продолжить работу
И она возвращается к тому же самому P, где и была раньше (если размер локальной очереди позволяет), либо чихвостит в глобальную очередь
В доке это описано как возвращение к P, только если он не является недоступным

Есть одна интересная проблема - что если, запустится в сервисе 10 000 соединений (к примеру) и тогда нужно 10 000 потоков? Жирно слишком
Для решения этой задачи используются мультиплексеры
В линуксе такой мультиплексер - это epoll 

В райтайме go есть отдельная сущность - netpoller 
Он поллит epoll линукса, справшивая, произошли ли определенные события

У epoll есть особенности:
- не попадают вызовы по работе с файлами, только с сетью 


Окей, локальная очередь понятна, теперь глобальная 
Sysmon, созданный на отдельном потоке ОС, один раз в 61 секунду (эмперически подобранное значение) 

Отдельные вопросы:
1. Можно ли в ручную завершить горутину:
runtime.Goexit()
2. Можно ли закрепить горутину за конкретным потоком?
Да, можно, есть функции в рантайме
3. Когда завершается работа горутины?
когда у нее нет больше кода 
4. Когда завершается выполнение программы?
Когда завершается выполнение функции main 
5. Что будет с теми горутинами, которые не успели выполнения до завершения работы программы?
Прерываются на том месте, когда программа завершилась 