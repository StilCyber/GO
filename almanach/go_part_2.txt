Базовый практический курс по языку GO, вторая часть

************************************************************************
Массивы 

Вы их уже успели лицезреть что-то подобное в первой части трилогии 
Сейчас продолжим 

////////////

lovers := [2]string{"Генерал Кастер", "Эрнан Кортес"}

fmt.Println(lovers) // [Генерал Кастер Эрнан Кортес]

////////////

Здесь мы создали массив из двух элементов и вывели его в консоль 
При создании массива в квадратных скобках указывается число элементов, затем тип данных, и собственно сами айтемы 

Массивы в GO не особо часто используются, поскольку есть их прокаченная версия - слайсы 
В массивах число элементов строго фиксировано и определяется при их создании
В слайсах количество элементов динамическое 

Массив - это коллекция однородных элементов
Однородных (в смысле гомогенных) - в смысле не только одного и того же типа данных, но еще и относящихся к чему-то... определенному 
Перечень любовников, перечень мужей, венерических заболеваний - эту всю прелесть можно представить в виде массива 

Один из приколов массивов в том, что мы может сразу же получить доступ к произвольному элементу
Каждый элемент массива обладает значением и индексом
Индекс определяет место элемента в массиве 
При каждом обращении к массиву индексы сохраняются 


////////////

lovers := [2]string{"Генерал Кастер", "Эрнан Кортес"}

fmt.Println(lovers[0]) // Генерал Кастер
fmt.Println(lovers[1]) // "Эрнан Кортес"

////////////

lovers := [2]string{"Генерал Кастер", "Эрнан Кортес"}

_ = lovers

fmt.Println(len(lovers)) // 2

////////////

_ = lovers - просто ставим заглушку чтобы go не ругался на неиспользованную переменную

Для определения длины массива используется функция len()
Важно - индексы начинаются с нуля, а длина считается с единицы
В массиве lovers есть элементы с индексом 0 и 1, а длина массива составляет 2

************************************************************************
Слайсы (срезы)

Вечно зеленая тема, номер 1 на собесах 

Слайсы - динамические массивы
При их создании мы не указываем количество элементов
Сами элементы мы может добавлять и удалять 

Под капотом у слайсов находится самый что ни на есть обычный фиксированный массив, об этом еще погорим

Итак, одна из самых частых операций со слайсами добавление нового элемента в конец

////////////

lovers := []string{"Генерал Кастер", "Эрнан Кортес"}

lovers = append(lovers, "Глеб Бокий")

for index, value := range lovers {
    fmt.Printf("Индекс: %v, Имя: %v\n", index, value)
}

// Индекс: 0, Имя: Генерал Кастер
// Индекс: 1, Имя: Эрнан Кортес
// Индекс: 2, Имя: Глеб Бокий

////////////

Глеб Бокий - русский революционер, стоял у истоков красного террора, курировал соловецкий лагерь,
             активно изучал мистику и оккультизм, устраивал массовые пьянки и оргии.
             Казнен в 37 году, в 56 году как порядочный человек посмертно реабилитирован. 

Добавление в конец производится благодаря функции append
Синтаксис именно такой:
lovers = append(lovers, "Глеб Бокий")

Когда мы добавляем элемент, нужно итоговый результат поместить в тот же или в другой слайс 
Первым параметром append принимает слайс, вторым - элемент, который добавляется в конец 

for index, value := range lovers {
    fmt.Printf("Индекс: %v, Имя: %v\n", index, value)
}

Вот эта конструкция - вариант цикла for, который работает с итерабельными типами данных 
Работает range следующим образом:
под капотом запускается функция, которая ретурнит индекс элемента массива и его значение (именно в таком порядке)

Также нельзя забыть про функцию len(), которая выводит длину слайса, массива, с определенными нюансами - строки

////////////

lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий"}
fmt.Println(len(lovers)) // 3

////////////

При помощи функции len() можно удобно получить последний элемент:

////////////

lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий"}

fmt.Println(lovers[len(lovers) - 1]) // Глеб Бокий

////////////

Удаление элементов из слайса происходит путем взятия подслайса: 

////////////

lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий"}

lovers = append(lovers, "Игорек")

fmt.Println(lovers[len(lovers) - 1]) // "Игорек"

lovers = lovers[:len(lovers) - 1]

for index, value := range lovers {
    fmt.Printf("Индекс: %v, Имя: %v\n", index, value)
}

// Индекс: 0, Имя: Генерал Кастер
// Индекс: 1, Имя: Эрнан Кортес
// Индекс: 2, Имя: Глеб Бокий

////////////

Подслайс берется с использованием двоеточия :
Это просто кусок слайса (да, кусок куска)

////////////

lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий"}

loversPart := lovers[:1]

fmt.Println(loversPart) // [Генерал Кастер]

////////////

lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий"}

loversPart := lovers[1:]

fmt.Println(loversPart) // [Эрнан Кортес Глеб Бокий]

////////////

При рассчете подслайса берется длина исходного слайса 
Здесь мы взяли подслайс со слайса lover - если двоеточие стоит перед цифрой, то берет элементы начиная с начала и до этой цифры включительно
loversPart := lovers[:1]

Если двоеточие стоит после цифры - то начиная с этой цифры и до конца:
loversPart := lovers[1:]

Если нам нужен подслайс где-то внутри слайса, то поступаем так:
loversPart := lovers[1:3]

Другие душеполезные приемы смотрите в альманахе 

Сейчас же мы наконец рассмотрим что эта хрень вообще такая

Слайс под капотом описывается следующей структурой:
type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
}

Там есть ссылка на базовый массив (array), длина слайса (length) и емкость (capacity)
Начнем с простого - длина
Когда мы пихаем слайс в len(), то это и есть его длина - количество элементов (счет начинается с единицы)
Ссылка (указатель) на базовый массив - как раз суть слайса
Внутрянка слайса - обычный неизменяемый массив 
И вот емкость как раз и указывает на длину базового массива
Когда мы аппендим новые элементы, они засовываются в свободные ячейки базового массива
А если ячейки заканчиваются - просто создается новый базовый массив где больше место, и в начало туда копируется предыдущий массив
Никакой магии, все просто и очевидно
У нас есть корзина с барахлом, когда там место заканчивается, мы берем корзину побольше и туда пересыпаем 


Теперь посмотрим одну интересную ситуацию 
Мариночка решила поделиться своими любовниками со своей подругой светкой 
Всеми, за исключением Генерала Кастера 
Светка очень быстро сделала одно интересное наблюдение
Вместо человека в шкуре ягуара стал приходит некто с головой орла 
И светка решила внести коррективы в "свой" подслайс с любовниками
Смотрим, что из этого вышло 

////////////

lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар"}
loversPart := lovers[1:]
loversPart[len(loversPart) - 1] = "Воин Орел"
fmt.Println(lovers)   // [Генерал Кастер Эрнан Кортес Глеб Бокий Воин Орел]
fmt.Println(loversPart) // [Эрнан Кортес Глеб Бокий Воин Орел]

////////////

Мариночка в гневе - она утверждает, что Воин Ягуар - это в целом один и тот же персонаж
И идентифицировать его как Воина Орла неправильно
Посмотрим что здесь происходит с указателями:

fmt.Printf("%p\n", lovers) // 0xc0000ba0c0
fmt.Printf("%p\n", loversPart) // 0xc0000ba0c0

Указатель стоит на одной и той же ячейке памяти 
Когда мы берем подслайс, данные не копируются - ссылка остается на все тот же самый базовый массив
Поэтому, при изменении подслайса, меняется и родительский слайс тоже 

Слайс обладает, как мы уже выяснили, тремя свойствами - ссылка на базовый массив, длина и емкость
Так вот, емкость - это ни что иное, как длина базового массива 
Т.е. длина слайса и длина массива, на который он ссылается - вещи разные 

Емкость (capaсity) - это общее число элементов базового массива 
Длина (length) - количество элементов самого слайса 

Емкость определяется при создании слайса:

lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар", "Воин Орел"}
fmt.Printf("Capacity: %v\n", cap(lovers)) // Capacity: 5

Аналогично при взятии подслайса:

lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар", "Воин Орел"}
loversPart := lovers[3:]
fmt.Printf("Capacity: %v\n", cap(loversPart)) // Capacity: 2

Создание слайса с использованием функции make - указывает тип слайса, длина и емкость
Здесь свободные элементы базового массива заполняются дефолтными значениями

lovers := make([]string, 0, 5)
fmt.Printf("Capacity: %v\n", cap(lovers))

А теперь попробуем добавить Воина Орла(приходит же все-таки к кому-то):
lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар"}
lovers = append(lovers, "Воин Орел")
fmt.Printf("Capacity: %v\n", cap(lovers)) // Capacity: 8

Функция append работает хитрым образом - она аллоцирует память (новое словечно чтобы выглядеть умным на собесах)
  определенными порциями. Т.е. есть пороговые значения
  которые зависят от типа данных 

Речь идет о функции growslice, которая выполняется в рантайме, вот ее исходники:
https://github.com/golang/go/blob/3902e9ef4e4543c6ac7371174a122ca090af971a/src/runtime/slice.go

Раньше пороговые значения хардкодились прям там, а теперь они скармливаются функции при вызове 
Можете убедиться в этом, набросав небольшой цикл, добавляющий элементы в слайс и при каждой итерации показывающий капасити
Для int увеличение капасити идет следующим образом:
// 2
// 4
// 8
// 16
// 32
// 64
// 128
// 256
// 512
// 848
// 1280
// 2560

Для стринги:
// 2
// 4
// 8
// 16
// 32
// 71
// 143
// 303
// 591
// 1023

Раньше все было проще и емкость бралась в основном по степеням двойки

А бывают ли слайсы с нулевой емкостью? Конечно же да! Иначе скучно пришлось бывают

var lovers []string
fmt.Println(lovers)
fmt.Printf("Length: %v\nCapacity: %v\n", len(lovers), cap(lovers))
fmt.Println(lovers == nil)

lovers = append(lovers, "Воин Орел")
fmt.Println(lovers)

// []
// Length: 0
// Capacity: 0
// true
// [Воин Орел]

Слайс без инициализации равен nil и имеет нулевую емкость
При добавлении элемента в такой слайс создается другой базовый массив
При проверке слайса на наличие в нем элементов всегда пользуйтесь 
    функцией len(), не сравнивайте с nil, не надо так 




Теперь поговорим еще раз о дилемме светки
Она не хочет ссориться с подругой, но хочет точно такой же список любовников
Ее предположение - что нужно просто прокрутить слайс любовников в другой функции
Ну что же, проверим

////////////

func main() {

	lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар"}

	fmt.Println(lovers)
	changeLovers(lovers)
	fmt.Println(lovers)

} 

func changeLovers(lovers []string) {
	lovers[len(lovers) - 1] = "Воин Орел"
}

// [Генерал Кастер Эрнан Кортес Глеб Бокий Воин Ягуар]
// [Генерал Кастер Эрнан Кортес Глеб Бокий Воин Орел]

////////////

Ха-ха, слайсы - это вам не числа, строки и булевы значения, он передается по указателю и не копируется

А что же тогда  append?

Светка немного подумала, и решала не ссориться с подругой и добавила Воина Орла отдельно:

////////////

lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар"}
loversPart := lovers[1:]
loversPart = append(loversPart, "Воин Орел")
fmt.Println(lovers) // [Генерал Кастер Эрнан Кортес Глеб Бокий Воин Ягуар]
fmt.Println(loversPart) // [Эрнан Кортес Глеб Бокий Воин Ягуар Воин Орел]

////////////

Что за... Нет, погодите, мы же только что выяснили, что манипуляции с подслайсами плохо заканчиваются
append, что ты вообще такое

fmt.Printf("%p\n", lovers) // 0xc0000ba0c0
fmt.Printf("%p\n", loversPart) // 0xc0000ac1e0

И еще вот такой пример

////////////

lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар"}
loversPart := lovers[:3]
loversPart = append(loversPart, "Воин Орел")
fmt.Println(lovers) // [Генерал Кастер Эрнан Кортес Глеб Бокий Воин Орел]
fmt.Println(loversPart) // [Эрнан Кортес Глеб Бокий Воин Ягуар Воин Орел]

////////////

Когда мы пытаемся что-то аппендить, то go смотрит на базовый массив и его емкость
В первом случае, когда мы брали подслайс loversPart := lovers[1:] 
   последний элемент слайса - это последний элемент базового массива
   поэтому место закончилось, и go скопировал массив и сделал вставку
Второй случай - loversPart := lovers[:3] - в базовом массиве еще было место
   поэтому go посмотрел такой, и ничего копировать не стал и тупо перезаписал 

А как правило тогда?
Перед такого рода манипуляциями нужно самостоятельно копировать подслайс (хочешь что-то сделать хорошо - делай сам)

////////////

lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар"}
loversCopy := make([]string, len(lovers))
copy(loversCopy, lovers)
loversPart := loversCopy[:3]
loversPart = append(loversPart, "Воин Орел")
fmt.Println(lovers) // [Генерал Кастер Эрнан Кортес Глеб Бокий Воин Ягуар]
fmt.Println(loversPart) // [Генерал Кастер Эрнан Кортес Глеб Бокий Воин Орел]

////////////

Наконец-то. Здесь мы создали копию слайса, сняли с копии подслайс и в него добавили что хотели 
Копия слайса, конечно же, тоже изменилась, но исходный слайс - нет 
Когда подготавливаем копию слайса, нужно указать длину как в исходном массиве
Этого светка и добавалась 

************************************************************************
Мапы 