Базовый практический курс по языку GO, вторая часть

************************************************************************
Массивы 

Вы их уже успели лицезреть что-то подобное в первой части трилогии 
Сейчас продолжим 

////////////

lovers := [2]string{"Генерал Кастер", "Эрнан Кортес"}

fmt.Println(lovers) // [Генерал Кастер Эрнан Кортес]

////////////

Здесь мы создали массив из двух элементов и вывели его в консоль 
При создании массива в квадратных скобках указывается число элементов, затем тип данных, и собственно сами айтемы 

Массивы в GO не особо часто используются, поскольку есть их прокаченная версия - слайсы 
В массивах число элементов строго фиксировано и определяется при их создании
В слайсах количество элементов динамическое 

Массив - это коллекция однородных элементов
Однородных (в смысле гомогенных) - в смысле не только одного и того же типа данных, но еще и относящихся к чему-то... определенному 
Перечень любовников, перечень мужей, венерических заболеваний - эту всю прелесть можно представить в виде массива 

Один из приколов массивов в том, что мы может сразу же получить доступ к произвольному элементу
Каждый элемент массива обладает значением и индексом
Индекс определяет место элемента в массиве 
При каждом обращении к массиву индексы сохраняются 


////////////

lovers := [2]string{"Генерал Кастер", "Эрнан Кортес"}

fmt.Println(lovers[0]) // Генерал Кастер
fmt.Println(lovers[1]) // "Эрнан Кортес"

////////////

lovers := [2]string{"Генерал Кастер", "Эрнан Кортес"}

_ = lovers

fmt.Println(len(lovers)) // 2

////////////

_ = lovers - просто ставим заглушку чтобы go не ругался на неиспользованную переменную

Для определения длины массива используется функция len()
Важно - индексы начинаются с нуля, а длина считается с единицы
В массиве lovers есть элементы с индексом 0 и 1, а длина массива составляет 2

************************************************************************
Слайсы (срезы)

Вечно зеленая тема, номер 1 на собесах 

Слайсы - динамические массивы
При их создании мы не указываем количество элементов
Сами элементы мы может добавлять и удалять 

Под капотом у слайсов находится самый что ни на есть обычный фиксированный массив, об этом еще погорим

Итак, одна из самых частых операций со слайсами добавление нового элемента в конец

////////////

lovers := []string{"Генерал Кастер", "Эрнан Кортес"}

lovers = append(lovers, "Глеб Бокий")

for index, value := range lovers {
    fmt.Printf("Индекс: %v, Имя: %v\n", index, value)
}

// Индекс: 0, Имя: Генерал Кастер
// Индекс: 1, Имя: Эрнан Кортес
// Индекс: 2, Имя: Глеб Бокий

////////////

Глеб Бокий - русский революционер, стоял у истоков красного террора, курировал соловецкий лагерь,
             активно изучал мистику и оккультизм, устраивал массовые пьянки и оргии.
             Казнен в 37 году, в 56 году как порядочный человек посмертно реабилитирован. 

Добавление в конец производится благодаря функции append
Синтаксис именно такой:
lovers = append(lovers, "Глеб Бокий")

Когда мы добавляем элемент, нужно итоговый результат поместить в тот же или в другой слайс 
Первым параметром append принимает слайс, вторым - элемент, который добавляется в конец 

for index, value := range lovers {
    fmt.Printf("Индекс: %v, Имя: %v\n", index, value)
}

Вот эта конструкция - вариант цикла for, который работает с итерабельными типами данных 
Работает range следующим образом:
под капотом запускается функция, которая ретурнит индекс элемента массива и его значение (именно в таком порядке)

Также нельзя забыть про функцию len(), которая выводит длину слайса, массива, с определенными нюансами - строки

////////////

lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий"}
fmt.Println(len(lovers)) // 3

////////////

При помощи функции len() можно удобно получить последний элемент:

////////////

lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий"}

fmt.Println(lovers[len(lovers) - 1]) // Глеб Бокий

////////////

Удаление элементов из слайса происходит путем взятия подслайса: 

////////////

lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий"}

lovers = append(lovers, "Игорек")

fmt.Println(lovers[len(lovers) - 1]) // "Игорек"

lovers = lovers[:len(lovers) - 1]

for index, value := range lovers {
    fmt.Printf("Индекс: %v, Имя: %v\n", index, value)
}

// Индекс: 0, Имя: Генерал Кастер
// Индекс: 1, Имя: Эрнан Кортес
// Индекс: 2, Имя: Глеб Бокий

////////////

Подслайс берется с использованием двоеточия :
Это просто кусок слайса (да, кусок куска)

////////////

lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий"}

loversPart := lovers[:1]

fmt.Println(loversPart) // [Генерал Кастер]

////////////

lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий"}

loversPart := lovers[1:]

fmt.Println(loversPart) // [Эрнан Кортес Глеб Бокий]

////////////

При рассчете подслайса берется длина исходного слайса 
Здесь мы взяли подслайс со слайса lover - если двоеточие стоит перед цифрой, то берет элементы начиная с начала и до этой цифры включительно
loversPart := lovers[:1]

Если двоеточие стоит после цифры - то начиная с этой цифры и до конца:
loversPart := lovers[1:]

Если нам нужен подслайс где-то внутри слайса, то поступаем так:
loversPart := lovers[1:3]

Другие душеполезные приемы смотрите в альманахе 

Сейчас же мы наконец рассмотрим что эта хрень вообще такая

Слайс под капотом описывается следующей структурой:
type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
}

Там есть ссылка на базовый массив (array), длина слайса (length) и емкость (capacity)
Начнем с простого - длина
Когда мы пихаем слайс в len(), то это и есть его длина - количество элементов (счет начинается с единицы)
Ссылка (указатель) на базовый массив - как раз суть слайса
Внутрянка слайса - обычный неизменяемый массив 
И вот емкость как раз и указывает на длину базового массива
Когда мы аппендим новые элементы, они засовываются в свободные ячейки базового массива
А если ячейки заканчиваются - просто создается новый базовый массив где больше место, и в начало туда копируется предыдущий массив
Никакой магии, все просто и очевидно
У нас есть корзина с барахлом, когда там место заканчивается, мы берем корзину побольше и туда пересыпаем 


Теперь посмотрим одну интересную ситуацию 
Мариночка решила поделиться своими любовниками со своей подругой светкой 
Всеми, за исключением Генерала Кастера 
Светка очень быстро сделала одно интересное наблюдение
Вместо человека в шкуре ягуара стал приходит некто с головой орла 
И светка решила внести коррективы в "свой" подслайс с любовниками
Смотрим, что из этого вышло 

////////////

lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар"}
loversPart := lovers[1:]
loversPart[len(loversPart) - 1] = "Воин Орел"
fmt.Println(lovers)   // [Генерал Кастер Эрнан Кортес Глеб Бокий Воин Орел]
fmt.Println(loversPart) // [Эрнан Кортес Глеб Бокий Воин Орел]

////////////

Мариночка в гневе - она утверждает, что Воин Ягуар - это в целом один и тот же персонаж
И идентифицировать его как Воина Орла неправильно
Посмотрим что здесь происходит с указателями:

fmt.Printf("%p\n", lovers) // 0xc0000ba0c0
fmt.Printf("%p\n", loversPart) // 0xc0000ba0c0

Указатель стоит на одной и той же ячейке памяти 
Когда мы берем подслайс, данные не копируются - ссылка остается на все тот же самый базовый массив
Поэтому, при изменении подслайса, меняется и родительский слайс тоже 

Слайс обладает, как мы уже выяснили, тремя свойствами - ссылка на базовый массив, длина и емкость
Так вот, емкость - это ни что иное, как длина базового массива 
Т.е. длина слайса и длина массива, на который он ссылается - вещи разные 

Емкость (capaсity) - это общее число элементов базового массива 
Длина (length) - количество элементов самого слайса 

Емкость определяется при создании слайса:

lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар", "Воин Орел"}
fmt.Printf("Capacity: %v\n", cap(lovers)) // Capacity: 5

Аналогично при взятии подслайса:

lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар", "Воин Орел"}
loversPart := lovers[3:]
fmt.Printf("Capacity: %v\n", cap(loversPart)) // Capacity: 2

Создание слайса с использованием функции make - указывает тип слайса, длина и емкость
Здесь свободные элементы базового массива заполняются дефолтными значениями

lovers := make([]string, 0, 5)
fmt.Printf("Capacity: %v\n", cap(lovers))

А теперь попробуем добавить Воина Орла(приходит же все-таки к кому-то):
lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар"}
lovers = append(lovers, "Воин Орел")
fmt.Printf("Capacity: %v\n", cap(lovers)) // Capacity: 8

Функция append работает хитрым образом - она аллоцирует память (новое словечно чтобы выглядеть умным на собесах)
  определенными порциями. Т.е. есть пороговые значения
  которые зависят от типа данных 

Речь идет о функции growslice, которая выполняется в рантайме, вот ее исходники:
https://github.com/golang/go/blob/3902e9ef4e4543c6ac7371174a122ca090af971a/src/runtime/slice.go

Раньше пороговые значения хардкодились прям там, а теперь они скармливаются функции при вызове 
Можете убедиться в этом, набросав небольшой цикл, добавляющий элементы в слайс и при каждой итерации показывающий капасити
Для int увеличение капасити идет следующим образом:
// 2
// 4
// 8
// 16
// 32
// 64
// 128
// 256
// 512
// 848
// 1280
// 2560

Для стринги:
// 2
// 4
// 8
// 16
// 32
// 71
// 143
// 303
// 591
// 1023

Раньше все было проще и емкость бралась в основном по степеням двойки

А бывают ли слайсы с нулевой емкостью? Конечно же да! Иначе скучно пришлось бывают

var lovers []string
fmt.Println(lovers)
fmt.Printf("Length: %v\nCapacity: %v\n", len(lovers), cap(lovers))
fmt.Println(lovers == nil)

lovers = append(lovers, "Воин Орел")
fmt.Println(lovers)

// []
// Length: 0
// Capacity: 0
// true
// [Воин Орел]

Слайс без инициализации равен nil и имеет нулевую емкость
При добавлении элемента в такой слайс создается другой базовый массив
При проверке слайса на наличие в нем элементов всегда пользуйтесь 
    функцией len(), не сравнивайте с nil, не надо так 




Теперь поговорим еще раз о дилемме светки
Она не хочет ссориться с подругой, но хочет точно такой же список любовников
Ее предположение - что нужно просто прокрутить слайс любовников в другой функции
Ну что же, проверим

////////////

func main() {

	lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар"}

	fmt.Println(lovers)
	changeLovers(lovers)
	fmt.Println(lovers)

} 

func changeLovers(lovers []string) {
	lovers[len(lovers) - 1] = "Воин Орел"
}

// [Генерал Кастер Эрнан Кортес Глеб Бокий Воин Ягуар]
// [Генерал Кастер Эрнан Кортес Глеб Бокий Воин Орел]

////////////

Ха-ха, слайсы - это вам не числа, строки и булевы значения, он передается по указателю и не копируется

А что же тогда  append?

Светка немного подумала, и решала не ссориться с подругой и добавила Воина Орла отдельно:

////////////

lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар"}
loversPart := lovers[1:]
loversPart = append(loversPart, "Воин Орел")
fmt.Println(lovers) // [Генерал Кастер Эрнан Кортес Глеб Бокий Воин Ягуар]
fmt.Println(loversPart) // [Эрнан Кортес Глеб Бокий Воин Ягуар Воин Орел]

////////////

Что за... Нет, погодите, мы же только что выяснили, что манипуляции с подслайсами плохо заканчиваются
append, что ты вообще такое

fmt.Printf("%p\n", lovers) // 0xc0000ba0c0
fmt.Printf("%p\n", loversPart) // 0xc0000ac1e0

И еще вот такой пример

////////////

lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар"}
loversPart := lovers[:3]
loversPart = append(loversPart, "Воин Орел")
fmt.Println(lovers) // [Генерал Кастер Эрнан Кортес Глеб Бокий Воин Орел]
fmt.Println(loversPart) // [Эрнан Кортес Глеб Бокий Воин Ягуар Воин Орел]

////////////

Когда мы пытаемся что-то аппендить, то go смотрит на базовый массив и его емкость
В первом случае, когда мы брали подслайс loversPart := lovers[1:] 
   последний элемент слайса - это последний элемент базового массива
   поэтому место закончилось, и go скопировал массив и сделал вставку
Второй случай - loversPart := lovers[:3] - в базовом массиве еще было место
   поэтому go посмотрел такой, и ничего копировать не стал и тупо перезаписал 

А как правило тогда?
Перед такого рода манипуляциями нужно самостоятельно копировать подслайс (хочешь что-то сделать хорошо - делай сам)

////////////

lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар"}
loversCopy := make([]string, len(lovers))
copy(loversCopy, lovers)
loversPart := loversCopy[:3]
loversPart = append(loversPart, "Воин Орел")
fmt.Println(lovers) // [Генерал Кастер Эрнан Кортес Глеб Бокий Воин Ягуар]
fmt.Println(loversPart) // [Генерал Кастер Эрнан Кортес Глеб Бокий Воин Орел]

////////////

Наконец-то. Здесь мы создали копию слайса, сняли с копии подслайс и в него добавили что хотели 
Копия слайса, конечно же, тоже изменилась, но исходный слайс - нет 
Когда подготавливаем копию слайса, нужно указать длину как в исходном массиве
Этого светка и добавалась 


************************************************************************
Структуры

Теперь пришло время для конкретики
Надо определить, какими атрибутами обладают женщины, их любовники и мужья 

Для создания кастомных типов в go используется ключевое слово type
   которое указывает на создание пользовательского объекта

    type Woman struct{
        Name string
        Age uint8
    }

В структуре указывается название поля и его тип 
Структура является абстракцией, на основе которой производится работа с данными

	user := Woman{"Мариночка", 25}
	fmt.Println(user) // 

При создании переменной на основе структуры можно не указывать названия полей:

	user := Woman{"Мариночка", 25}

Здесь главное соблюдать порядок, однако читаемость кода сильно страдает 

Можно выводить в консоль вместе с названиями полей вот таким незамысловатым способом:

	user := Woman{"Мариночка", 25}
	fmt.Printf("User: %+v\n", user) // User: {Name:Мариночка Age:25}

Теперь будет интересней - в качестве типа поля структуры может выступать... другая структура

    type Woman struct{
        Name string 
        Age uint8
        Lovers []Lovers
        Husband Husband
        Сonscience bool	
    }

    type Lovers struct{
        Name string
        PersonalityDisorder string
        Audacity uint8
        Sociability uint8
        Fear uint8
        Сonscience bool
    }

    type Husband struct{
        Name string 
        Responsibility uint8
        Patience uint8
        Audacity uint8
        Sociability uint8
        Fear uint8
        Сonscience bool
        Income int
    }

Шикарно

Структуры любовников и мужей отличаются
Любовники обладают такими эксклюзивными атрибутами, как расстройство личности и дерзость
Для мужей важны ответственность, терпение и доход
Женщины могут иметь много любовников []Lovers, и только одного мужа 

Теперь давайте делать все как полагается, но перед этим решим одну проблему
Список расстройств личности у любовников (PersonalityDisorder) строго ограничен
Женщин интересуют только следующие четыре:
- антисоциальное расстройство
- нарциссическое расстройство
- истерическое расстройство
- пограничное расстройство

И мы же не будем их хардкодить, да? 
Описывать их как структуру тоже не выйдет
Значит, нам нужно перечисление, на которое мы будем ссылаться
Такая штука называется enum
Вот только загвоздка в том, что в go нет никакого enum
Enum - это перечисляемый тип (enumerable), который используется во многих других языках
Чтобы использовать enum в go, нужно... написать его самим 

Итак, что мы делаем 

Здесь мы воспользуемся кастомными типами
Как и структуры, они объявляются словом type 

type PersonalityDisorders int

Отлично, эта хня теперь будет вести себя как обычное число, казалось бы зачем. А вот нужно

    const (
        AntisocialDisorder PersonalityDisorders = 1
        NarcissisticDisorder PersonalityDisorders = 2
        HystericalDisorder PersonalityDisorders = 3
        BorderlineDisorder PersonalityDisorders = 4
    )

Окей, теперь мы может поменять тип атрибута PersonalityDisorder на PersonalityDisorders
И указывать константы, где каждому расстройству соответствует своя цифра
Сейчас мы уже может с этим работать, и go при заполнении значения этого поля будет предлагать созданные константы
Но, это пока все равно не то

    lovers := []Lovers{{Name: "Генерал Кастер", PersonalityDisorder: AntisocialDisorder, Audacity: 255, Sociability: 255, Fear: 0, Сonscience: false }}
	fmt.Println(lovers) // [{Генерал Кастер 1 255 255 0 false}]

В логах выводится число, а нам надо само расстройство 

Одна из фишек кастомных типов - возможность использовать методы и интерфейсы
Реализуем встроенный интерфейс String для нашего типа

func (p PersonalityDisorders) String() string {
    switch p:
    case AntisocialDisorder:
        return "Антисоциальное расстройство"
    case NarcissisticDisorder:
        return "Нарциссическое расстройство"
    case HystericalDisorder:
        return "Истерическое расстройство"
    case BorderlineDisorder:
        return "Пограничное расстройство"
    default:
        return "Unknown"
}

Отлично, и еще один нюанс
Мы не хотим хардкодить цифры в значениях констант
Здесь можно использовать такую штуку, как iota
В пределах блока констант она будет генерировать тип и цисловые последовательности на основе первой константы

Итак, вот код, который у нас получился

    type PersonalityDisorders int

    const (
        AntisocialDisorder   PersonalityDisorders = iota
        NarcissisticDisorder 
        HystericalDisorder   
        BorderlineDisorder   
    )

    func (p PersonalityDisorders) String() string {
        switch p {
        case AntisocialDisorder:
            return "Антисоциальное расстройство"
        case NarcissisticDisorder:
            return "Нарциссическое расстройство"
        case HystericalDisorder:
            return "Истерическое расстройство"
        case BorderlineDisorder:
            return "Пограничное расстройство"
        default:
            return "Unknown"

        }
    }

    type Woman struct {
        Name       string
        Age        uint8
        Lovers     []Lovers
        Husband    Husband
        Сonscience bool
    }

    type Lovers struct {
        Name                string
        PersonalityDisorder PersonalityDisorders
        Audacity            uint8
        Sociability         uint8
        Fear                uint8
        Сonscience          bool
    }

    type Husband struct {
        Name           string
        Responsibility uint8
        Patience       uint8
        Audacity       uint8
        Sociability    uint8
        Fear           uint8
        Сonscience     bool
        Income         int
    }

    func main() {

        lovers := []Lovers{{Name: "Генерал Кастер", PersonalityDisorder: AntisocialDisorder, Audacity: 255, Sociability: 255, Fear: 0, Сonscience: false}}
        fmt.Println(lovers) // [{Генерал Кастер Антисоциальное расстройство 255 255 0 false}]

    }

Осмыслить это можно чуть позже, когда перейдем к интерфейсам, а сейчас просто возьмите на заметку, что так можно

Есть еще одна проблема, которая вызывает беспокойство
Мы можем заменить, что ряд полей повторяется - везде есть Name,
у мужчин и мужей есть страх и ответственность
Что с этим делать? Зачем нам такое дублирование?
В других языках такие кейсы разрузливаются наследованием 
Т.е. нужен родительский тип, от которого мы будем брать поля 
В нашем случае - вот такой

type Person struct {
	Name       string
	Fear       uint8
	Сonscience bool
}

Однако, в go наследования нет
Вместо него используется другой паттерн - композиция (встраивание)
Фактически, мы будем помещать одну структуру внутрь другой, как уже делали ранее, но с нюансами

type Lovers struct {
	Person
	PersonalityDisorder PersonalityDisorders
	Audacity            uint8
	Sociability         uint8
}

Здесь, если имя поля и типа данных совпадает, то можно не дублировать
Так выглядит композиция структур 
У женщин и мужей тоже встроим Person 
Теперь поправим немного слайс

    lovers := []Lovers{{Person: Person{Name: "Генерал Кастер", Fear: 0, Сonscience: false}, PersonalityDisorder: AntisocialDisorder, Audacity: 255, Sociability: 255}}
    fmt.Println(lovers) // [{{Генерал Кастер 0 false} Антисоциальное расстройство 255 255}]

Ладно, допустим
Но все равно есть еще к чему придраться


Достаточно простой, но важный момент - получение отдельных полей экземпляра структуры. 
Делается это несложно, вот такой синтаксис

	lovers := []Lovers{{Person: Person{Name: "Генерал Кастер", Fear: 0, Сonscience: false}, PersonalityDisorder: AntisocialDisorder, Audacity: 255, Sociability: 255}}
	fmt.Println(lovers[0].Audacity) // 255
	fmt.Println(lovers[0].Person.Name) // Генерал Кастер
    fmt.Println(lovers[0].Name) // Генерал Кастер

Здесь у нас структура - нулевой элемент слайса, поэтому нужно получить сначала его
Получить доступ к полям встроенной структуры - можно как через нее, так и напрямую. Удобно

Настало время узнать, как передавать структуры в функции и возвращать их
При передаче аргументом структуры полностью копируются
Поэтому, если мы хотим сэкономить память, то лучше передавать указатель
Также если мы возвращаем из функции структуру, то можно вернуть указатель на нее 
В принципе, если данных в структуре немного, то можно не заморачиваться с указателями

    func main() {

        lovers := []Lovers{
            {Person: Person{Name: "Генерал Кастер", Fear: 0, Сonscience: false}, PersonalityDisorder: AntisocialDisorder, Audacity: 255, Sociability: 255},
            {Person: Person{Name: "Эрнан Кортес", Fear: 15, Сonscience: false}, PersonalityDisorder: AntisocialDisorder, Audacity: 220, Sociability: 255},
        }

        fmt.Println(maxPoint(&lovers[0]))
        fmt.Println(findMaxAudacity(lovers))


    }

    func maxPoint(lover *Lovers) int {

	    return int(lover.Audacity) + int(lover.Sociability) - int(lover.Fear)
    }

    func findMaxAudacity(lovers []Lovers) *Lovers {
        ind := 0

        for i := 1; i < len(lovers); i++ {
            if lovers[i].Audacity > lovers[ind].Audacity {
                ind = i
            }
        }

        return &lovers[ind]
    }

Функция maxPoint аргументом принимает указатель на структуру Loveres 
Задача функции - подсчитать количество очков - складываем "положительные" качества и вычитаем отрицательные
Поскольку типы данных атрибутов uint8, нужно преобразовать в int чтобы все получилось 

Функция findMaxAudacity находит самого дерзкого любовника
Здесь передавать аргументом указател смысла нет - поскольку передается слайс, 
а слайс всегда передается по ссылке (поскольку слайс и есть указатель плюс длина и емкость, сам она данных не содержит)
Но, из функции мы уже возвращаем конкретную структуру, а точнее, указатель на нее
Кстати, когда мы обращаемся к полям переданной по указателю структуры, то оператор разыменования ставить не нужно -
в go это сделано уже под капотом для нашего удобства



Мелкие лафхаки

Инициализация с дефолтными значениями

	lovers := Lovers{}
	fmt.Println(lovers) // {{ 0 false} Антисоциальное расстройство 0 0}

Откуда взялось расстройство личности? Да все просто - в нашем кастомном enum 
за основу взят тип int, его дефолтное значение это 0, а нулю соответствует именно это расстройство


Структуру можно создать не отходя от кассы - сразу при создании ее экземпляра
lovers := struct {
		Person
		PersonalityDisorder PersonalityDisorders
		Audacity            uint8
		Sociability         uint8
	}{
		Person: Person{Name: "Генерал Кастер", Fear: 0, Сonscience: false}, 
		PersonalityDisorder: AntisocialDisorder, 
		Audacity: 255, 
		Sociability: 255,
	}


Но, это будет анонимная структура, и мы не сможем ее встраивать - жирный минус и плохая читаемость кода
Теперь идем дальше

************************************************************************
Методы

Тема методов, применительно к go, достаточно проста. 
Понятие метода пришло из парадигмы объектно-ориентированного программирования (ООП)
Метод - это функция, которая принадлежит объекту 
ООП зиждется на том, что мы описываем сущности как объекты реального мира 
А у объектов есть атрибуты и функции
Вот пример
У Генерала Кастера есть такие атрибуты, как имя, дерзость, коммуникабельность и прочее
Отлично, а что же он умеет делать?
Метод - это конкретное действие
Допустим, бухать 
Бухать - это метод
И методы связаны с определенными атрибутами
Представим, что у него есть шкала здоровья в 200 очков 
И, когда он начинает пить, то здоровье повышается, но до определенных пределов 
После достижения отметки в два промилле спирта в крови, здоровье начинает падать 
Очевидно, что для реализации такого действия нужна отдельная функция
И, поскольку эта функция будет неразрывно связана с конкретным объектом, 
предки современных программистов решили привязать такие функции к ним особым образом

Собственно, это вся базовая теория про методы 
Из нее вытекает, что у метода есть следующие особенности:
- связь с определенной структурой
- возможность, как и в обычные функции, что-то прокинуть аргументами

type Person struct {
	Name       string
	Fear       uint8
	Сonscience bool
    Health     uint8
}

И реализуем метод для типа Lover (поскольку мы встроили туда структуру Person, можно работать и с нее полями тоже)

func main() {

	lovers := []Lovers{
		{Person: Person{Name: "Генерал Кастер", Fear: 0, Сonscience: false, Health: 210}, PersonalityDisorder: AntisocialDisorder, Audacity: 255, Sociability: 255},
	}
	lovers[0].drinked(1.7)
}

func (l *Lovers) drinked(promille float64) {
	if promille <= 0 {
		return
	}

	var (
		smallPromille  = 1.5
		middlePromille = 2.0
	)


	if l.Health < 255 {
		if promille < smallPromille {
			l.Health += 5
			fmt.Printf("Очки здоровья: %v\n", l.Health)
			return
		}

		if promille < middlePromille {
			l.Health += 10
			fmt.Printf("Очки здоровья: %v\n", l.Health)
			return
		}
	}

	if promille > middlePromille {
		l.Health -= 15
		fmt.Printf("Очки здоровья: %v\n", l.Health)
		return
	}
}

 Разберем саму функцию
 func (l *Lovers) drinked(promille float64) {}


Собственно, drinked(promille float64) - просто название метода и описание параметров
(l *Lovers) - так называемый ресивер
Здесь метод принимает указатель на структуру Lovers
Заострим внимание - тут есть защита от дурака
При вызове метода без разницы, что вы передаете - саму структуру или указатель на нее
Метод сам определит что ему надо
К примеру, здесь мы передали структуру там, где требовался указатель - и окей
Go сам взял указатель на эту структуру
То есть, приоритет здесь - то, что описано в самом методе

Вот, в принципе, и все по методам
Осталось только поговорить про некоторые... ограничения

Ограничения по работе с методами:
1. Метод и структура должны находиться в одном пакете (нельзя написать метод для структуры, которая валяется не пойми где)
2. Нельзя написать метод для указателя на структуру
   Логика здесь простая - ресивером может быть указатель, а указатель не может указывать на другой указатель
3. Мы не может добавить метод для интерфейса 
4. Нельзя добавлять методы для встроенных типов (к примеру, для стринги, int и другого)
   Но, если мы создадим кастомный тип - тут уже пожалуйста  
5. Сначала яйцо, потом курица - сначала создаем структуру, и затем метод к ней 
   Нельзя создать метод для необъявленной структуры
Кстати, если метод написан с другой буквы, мы сможем вызывать его из других пакетов

************************************************************************
Интерфейсы

Вот, наконец, мы дошли до них 
Встречайте. Интерфейсы - в студию

У мариночки есть список требований к мужу и отдельные пожелания к любовникам 
Муж пренепременно должен уметь делать следующее:
- отдавать доход (есть что взять)
- терпеть все ее выходки (ведется на манипуляции)

Ей без разницы какой конкретно человек будет ее мужем - главное, чтобы соблюдалось два условия 
Это необходимое и достаточное условия

type MyHusband interface {
    giveAwayIncome(request int) int
    tolerate(angryPoint int) bool
}

Вот и все - в интерфейсе прописывается только сигнатура функции (имя, параметры и возвращаемое значение)
Сами функции заранее, естественно, не создаются
Другими словами, интерфейс - это женские хотелки 

Создадим два метода для структуры Husband

    func (h *Husband) giveAwayIncome(request int) int {
        saveMoney := 500

        if h.Income <= saveMoney {
            fmt.Println("Заначку не забираем, пускай думает что я не знаю о ее существовании")
            return 0
        }

        var response int

        if (h.Income - request) >= saveMoney {
            response = h.Income - request
            h.Income -= request
            return response 
        } else {
            response = h.Income - saveMoney
            return response
        }
    }

    func (h *Husband) tolerate(angryPoint uint8) bool {
        h.Patience -= angryPoint
        
        if h.Patience <= 0 {
            fmt.Println("Материал отработан")
            return false
        }

        return true
    }

Структура соответствует интерфейсу, если реализует все его методы 
Вот любовники, к примеру, данные методы не реализуют, и под роль мужа не подходит 

Еще один небольшой штрих 

    type Woman struct {
        Person
        Age     uint8
        Lovers  []Lovers
        Husband MyHusband
    }

При описании типа атрибута Husband указываем уже не структуру, а интерфейс 
Тот же прием можно использовать, когда типизируем параметры функции 

Есть такая штука - полиморфизм называется 
Это когда в биологии один и тот же вид реализует разное поведение
Ну то есть, к примеру когда один человек пьет - и у него здоровье повышается
Другой человек пьет - и у него понижается
А бывает и так, что пьет один, а xp теряет кто-то другой 
Хотя все они просто пьют...

Напишем интерфейс с указанием одного метода, который будет реализован разными способами

type Human interface {
    drinked(promille float64) uint8
}

Все хьюман пьют (наверно, каждый просто что-то свое)
При питие у них увеличивает число промилле в крови 
Однако, результат у одного и того же действия разный 

Вот так вот пьет муж 

func (l *Husband) drinked(promille float64) uint8 {
	if promille <= 0 {
		return l.Health
	}

	var (
		smallPromille  = 1.5
		middlePromille = 2.0
	)

	if promille > middlePromille {
		l.Health -= 25
		fmt.Printf("Очки здоровья: %v\n", l.Health)
		return l.Health
	}

	if float64(l.Health)-promille <= 0 {
		return 0
	}

	if promille < smallPromille {
		l.Health -= 5
		fmt.Printf("Очки здоровья: %v\n", l.Health)
		return l.Health
	}

	if promille < middlePromille {
		l.Health -= 10
		fmt.Printf("Очки здоровья: %v\n", l.Health)
		return l.Health
	}

	return l.Health
}

А вот так пьют любовники

    func (l *Lover) drinked(promille float64, w *Woman) uint8 {
         if promille <= 0 {

         return w.Health
        }
    
    var (
		smallPromille  = 1.5
		middlePromille = 2.0
	)

	if promille > middlePromille {
		l.Health -= 25
		fmt.Printf("Очки здоровья: %v\n", l.Health)
		return l.Health
	}

	if float64(l.Health)-promille <= 0 {
		return 0
	}

	if promille < smallPromille {
		l.Health -= 5
		fmt.Printf("Очки здоровья: %v\n", l.Health)
		return l.Health
	}

	if promille < middlePromille {
		l.Health -= 10
		fmt.Printf("Очки здоровья: %v\n", l.Health)
		return l.Health
	}

	return l.Health



    }



************************************************************************
Мапы 