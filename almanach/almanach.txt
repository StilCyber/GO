// ПЕРЕМЕННЫЕ

var wife string
wife = "Кисуля"

wife := "Рыба моя"

var name, age = "Некая тян", 22

var (
	husband = true
	lovers = true
	children = 3
)

const law = "Семейный кодекс"

const mainLaw, codex = "Конституция", "Семейный кодекс"

const (
	mainLaw = "Конституция"
	codex = "Семейный кодекс"
)

Компилятор go требует, чтобы мы обязательно использовали объявленную переменную
var lovers = "Генерал Кастер"
_ = lovers

 Благодаря нижнему подчеркиваю, оно называется blank identifier, мы избежим ошибок при компиляции 
 Это особенно полезно в следующих случаях:
 1. Функция возвращает данные, и ошибку, если не хотим обрабатывать ошибку, заменяем ее _
 2. Импортируем пакет, который пока не хотим использовать, но импорт нужен обязательно или потребуется в будущем

// АРИФМЕТИКА

базовые операции - +, -, *, /
возведение в квадрат - ** 
остаток от деления - %

Одна из самых частых операций - увеличение на единицу 
Для этого есть краткий синтаксис

var i = 0
Вместо того, чтобы писать 
i = i + 1
можно записать так:
i++

Еще один вариант:
i += 1

Кстати, такой синтасис можно использовать и в других случаях:
var i = 0

i += 1 // 1
i *= 10 // 10
i -= 2 // 8

Для вычитания на единицу синтаксис схож:
i--

Прибавление единицы называется ИНКРЕМЕНТ
Вычитание единицы - ДЕКРЕМЕНТ

// УСЛОВИЯ И ЛОГИКА

базовое сравнение - >, <, >=, <=
равенство - == 
неравенство = !=

логические операции - отрицание, конъюнкция и дизъюнкция

Отрицание
fmt.Println(!true) // false

Конъюнкция (логическое умножение)
Если оба операнда истинны - только тогда будет true
fmt.Println(true && true) // true
fmt.Println(true && false) // false

Дизъюнкция (логическое сложение)
Хотя бы один операнд не должен быть false
fmt.Println(true || true) // true
fmt.Println(true || false) // true
fmt.Println(false || false) // false

Ложные значения в go:
false

В отличие от других языков, в go ложным является только false 
   нули, пустые строки в этом празднике жизни не участвуют

// УСЛОВНОЕ ВЕТВЛЕНИЕ и SWITCH

if условие {
	некий сомнительный код
 } else if другое условие {
	еще более подозрительно
 } else {
	если везде отшили
 }

 switch условие:
	case плохой вариант 1:
		код...
	case плохой вариант 2:
		код...
	default:
		обычная невезуха

// ЦИКЛЫ

// базовый вариант for 
children := 0

for i := 0; i < 3; i++ {
	fmt.Printf("Сейчас детей: %v\n", children)
	fmt.Println("Нужно родить еще")
	children++
}

// for как while
var lovers uint

fmt.Println("Введите количество любовников")
fmt.Scan(&lovers)

for lovers > 0 {
	fmt.Printf("Текущее число любовников: %v\n", lovers)
	lovers--
}

// ФУНКЦИИ

// пример функции с одним параметром и одним возвращаемым значением
func countLetters(num int) int {
	result := 0

	for i := 0; i <= num; i++ {
		result += i
	}

	return result
}

// вариант с созданием возвращаемой переменной при объявлении функции
func countLetters(num int) (sum int) {
	sum = 0

	for i := 0; i <= num; i++ {
		sum += i
	}

	return sum
}

// функция имеет доступ к внешним переменным
var lovers = []string{"Генерал Кастер", "Сальвадор Дали"}

func main() {
	listingLovers()
	
}

func listingLovers() {
	for _, value := range lovers {
		fmt.Println(value)
	}
}

// каноничный пример работы замыкания
func main() {
	test := counter()

	fmt.Println(test()) // 0
	fmt.Println(test()) // 1
	fmt.Println(test()) // 2

}

func counter() func() int {
	count := 0
	return func() int {
		value := count
		count++
		return value
	}
}

// МАССИВЫ И СЛАЙСЫ
Массив - упорядоченная коллекция данных, в случае с go - однородных, т.е. одного типа 
Массив в go имеет фиксированное количество элементов 

// создание массива - указывает число элементов, тип данных, и, собственно, сами элементы
lovers := [2]string{"Генерал Кастер", "Эрнан Кортес"}
fmt.Println(lovers) // [Генерал Кастер Эрнан Кортес]

// для ленивых - ставим три точки и go сам подсчитает число элементов
lovers := [...]string{"Генерал Кастер", "Эрнан Кортес"}
fmt.Println(lovers) // [Генерал Кастер Эрнан Кортес]

// крайне важно - элементов может быть меньше
lovers := [2]string{"Генерал Кастер"}
fmt.Println(lovers) // [Генерал Кастер ]

Если приглядеться, то там есть некий пробел в конце // [Генерал Кастер ]

// попробуем вот так
lovers := [2]string{"Генерал Кастер"}

	for index, value := range lovers {
		fmt.Printf("index: %v, тип: %T\n", index)
		fmt.Printf("value: %v\n", value)
	}

// index: 0
// value: Генерал Кастер
// index: 1
// value: 

Хмм... ничего туда не ложили, но что-то там есть... 

// идем дальше
lovers := [2]string{"Генерал Кастер"}

	for index, value := range lovers {
		fmt.Printf("index: %v, тип: %T\n", index, index)
		fmt.Printf("value: %v, тип: %T\n", value, value)
	}

// index: 0, тип: int
// value: Генерал Кастер, тип: string
// index: 1, тип: int
// value: , тип: string

Пустое место с типом string - и это, барабанная дробь... Да, это она, пустая строка ""

Есть такое понятие, как zero value - дефолтное значение, объявление без инициализации
Все пустующие элементы массива заполняются по дефолту 

Покажем более понятный кейс, и все встанет на свои места
Женщина с поэтическим турецким именем Наташа имеет четкие планы на жизнь
У нее экономическое образование, на базе которого созрел бизнес-план
Для того чтобы никогда не работать, она решает жить на алименты
Поскольку с одного мужчины получать алименты чаще всего нерентабельно,
   она решает родить троих детей от трех разных мужчин и трясти каждого из них 
Натали уже на пути к задуманному, и у нее уже есть два ребенка 

alimony := [3]uint{10000, 15000}

	for index, value := range alimony {
		fmt.Printf("ребенок №%v, алименты: %v\n", index, value)
	}

// ребенок №0, алименты: 10000
// ребенок №1, алименты: 15000
// ребенок №3, алименты: 0

zero value для типа данных uint - это 0 

Теперь слайсы 
Слайс - динамический массив, мы может добавлять туда произвольно число элементов

lovers := []string{"Генерал Кастер", "Эрнан Кортес"}

lovers = append(lovers, "Глеб Бокий")

for index, value := range lovers {
    fmt.Printf("Индекс: %v, Имя: %v\n", index, value)
}

// Индекс: 0, Имя: Генерал Кастер
// Индекс: 1, Имя: Эрнан Кортес
// Индекс: 2, Имя: Глеб Бокий

// получение длины слайса
lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий"}
fmt.Println(len(lovers)) // 3

// взятие подслайса
lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар"}

// cправа налево взять слайс нельзя - начальное число должно быть меньше конечного

loversStart := lovers[:1] // [Генерал Кастер]
loversStart := lovers[0:1] // [Генерал Кастер]
loversEnd := lovers[1:] // [Эрнан Кортес Глеб Бокий Воин Ягуар]
loversMiddle := lovers[1:3] // [Эрнан Кортес Глеб Бокий]

По словам мариночки, которая активно пользуется слайсом с любовниками,
   в последнее время слайс пополнился неким воином в ягуаровых одеяниях, который приходит в вечер пятницы
   с мексиканской самогонкой. Странные одеяния и непонятня речь не позволяют его идентифицировать,
   и сама мариночка не уверена в том, что в шкуре ягуара приходит один и тот же мужчина,
   однако он все равно учитывается как один экземпляр 


// удаление элемента слайса
Марина на приеме у доктора поняла, что ее плохое самочувствие связано с букетом венерических заболеваний
Однако, пройдя курс лечения, удалось победить одно из них
Создадим слайс с венерическими заболеваниями, и удалим из него один элемент

venerealDiseases := []string{"Гепатит С", "Хламидиоз", "Кандидоз", "Трихомониаз"}
venerealDiseases = append(venerealDiseases[:1], venerealDiseases[2:]...) // [Гепатит С Кандидоз Трихомониаз]

Три точки здесь выплевывают все элементы подслайса - эта фишка в том числе используется и в параметрах функций
Первым аргументом append принимает исходный слайс, а все последующие - элементы для вставки
Ладно, помогли немного женщине, идем дальше

// Функционал пакета slices
Сортировка 
venerealDiseases := []string{"Гепатит С", "Хламидиоз", "Кандидоз", "Трихомониаз"}
slices.Sort(venerealDiseases) // [Гепатит С Кандидоз Трихомониаз Хламидиоз]

Сравнение двух слайсов
loversForMarina := []string{"Воин Ягуар"}
loversForSveta := []string{"Воин Орел"}
fmt.Println(slices.Concat(loversForMarina, loversForSveta)) // [Воин Ягуар Воин Орел]

Есть ли элемент в слайсе
Мариночка не всегда всех помнит, поэтому 
   иногда хочет узнать, есть ли у нее конкретный любовник
   lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар"}
   fmt.Println(slices.Contains(lovers, "Воин Ягуар")) // true

Удаление элемента
Для мариночки есть еще один вариант вычеркивания вылеченных заболеваний
venerealDiseases := []string{"Гепатит С", "Хламидиоз", "Кандидоз", "Трихомониаз"}
venerealDiseases = slices.Delete(venerealDiseases, 1, 2) // [Гепатит С Кандидоз Трихомониаз]

В пакете slices есть много других функций
https://pkg.go.dev/slices
Правда, большая часть из них в принципе бесполезна

// МАПЫ
Мапа - тип для хранения данных в формате ключ - значение, т.е. хеш-таблица

// объявление пустой мапы 
var flock map[string]string
fmt.Printf("Тип мапы: %T\nЗначение мапы: %#v\n", flock, flock) 
    // Тип мапы: map[string]string
    // Значение мапы: map[string]string(nil)
fmt.Println(flock == nil) // true
fmt.Println(len(flock))  // 0
 
// создание мапы функцией make
flock := make(map[string]string, 5)
fmt.Printf("Тип мапы: %T\nЗначение мапы: %#v\n", flock, flock) 
    // Тип мапы: map[string]string
    // Значение мапы: map[string]string{}
fmt.Println(flock == nil) // false
fmt.Println(len(flock))  // 0

Функция make позволяет аллоцировать память под мапу
Здесь выделено памяти под 5 пар ключ-значение
Это не capacity как в слайсах 
Пустая мапа с аллоцированной памятью не равна nil

// создание мапы через литерал 
flock := map[string]string{
	"Шпиц": "Собакен",
	"Чихуа-хуа":  "Собакен",
}
fmt.Printf("Тип мапы: %T\nЗначение мапы: %#v\n", flock, flock) 
fmt.Println(len(flock)) 
	// Тип мапы: map[string]string
	// Значение мапы: map[string]string{"Чихуа-хуа":"Собакен", "Шпиц":"Собакен"}
	// 2

// создание мапы через new
flock := *new(map[string]string)
fmt.Printf("Тип мапы: %T\nЗначение мапы: %#v\n", flock, flock) 
    // Тип мапы: map[string]string
    // Значение мапы: map[string]string(nil)
fmt.Println(flock == nil) // true
fmt.Println(len(flock))  // 0

// создание мапы, с использованием структуры для значений
type characteristicsDogs struct {
	fear      uint8
	agression uint8
}

var flock = map[string]characteristicsDogs{
	"Шпиц":      {90, 152},
	"Чихуа-хуа": {255, 255},
	"Мопс":      {115, 82},
	"Пудель":    {199, 41},
}

// добавление данных в мапу
flock["Шиба-ину"] = characteristicsDogs{128, 42}

// изменение данных в мапе 
flock["Шпиц"] = characteristicsDogs{128, 142}

// полученые данных
flock["Мопс"]

Если введенного ключа не существует, то мы получим zero value для данного типа
Бывает так, что ключ и значение существуют, то значение соответствует дефолтному 

Добавим еще одного пса 
flock["Чау-чау"] = characteristicsDogs{0, 0}
fmt.Println(flock["Чау-чау"]) // {0, 0}

Попробуем получить данные о несуществующем собакене 

fmt.Println(flock["Гончий хрюндель"]) // {0, 0}

Выход здесь такой
value, isExist := flock["Гончий хрюндель"] // {0, 0}, false


// удаление данных 
Выпнем пуделя
delete(flock, "Пудель")

// итерация по мапе (мапа взята после предыдущих изменений)
for key, value := range flock {
	fmt.Printf("Key: %v Value: %v\n", key, value)
}

// Key: Чихуа-хуа Value: {255 255}
// Key: Мопс Value: {115 82}
// Key: Шиба-ину Value: {128 42}
// Key: Чау-чау Value: {0 0}
// Key: Шпиц Value: {128 142}

Порядок ключей в мапе рандомный, каждый раз будет по-разному, это вам не слайс

// Фильтрация уникальных значений
