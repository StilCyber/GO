************************************************************************
// Порядок установки

Начинаем с классики

    sudo apt update
    sudo apt upgrade

Инсталлируем postgres

    sudo apt install postgresql

Запускаем postgres (утилита systemctl управляет демонами линукса)

    sudo systemctl start postgresql

    ... и проверяем статус демона (должен быть зеленым)
    sudo systemctl status postgresql

    для рестарта (к примеру, при изменении конфигов) демона нужно пнуть 
    sudo systemctl restart postgresql

************************************************************************
// Заходим в пострес 

В постгресе есть свои отдельные пользователи, после установки доступен суперпользователь "postgres", который обладает неограниченными возможностями (что хочет создает, что хочет удаляет)
Для работы с постгресом из терминала используется отдельная консоль - psql. По сути это отдельный терминал, в котором можно вводить команды для работы с постгресом
Можно войти в аккаунт постгреса без входа в консоль psql, но в этом смысла особо нет. Для этого можно использовать следующую команду: sudo -i -u postgres 
Дело в том, что пользователи постгреса связаны с пользователями линукс. Поэтому, при установке пострес создается не только суперпользователь постгрес, но и одноименный аккаунт в операционной системе. 
И здесь нас ждет подстава - по умолчанию для пользователя postgres не задан пароль, поэтому нормально пользоваться им мы пока не сможет, но об этом чуть позже. 
Если вы все же ввели sudo -i -u postgres и не можете оттуда выйти, введите команду: su myAccount, где myAccount - имя вашего основного аккаунта в линуксе, от которого вы знаете пароль - введите этот пароль и возвращаетесь обратно

Для того, чтобы выбрать пользователя посгрес и сразу открыть psql, нужно ввести следующую команду: sudo -u postgres psql
Здесь мы заходим в аккаунт postgres в операционной системе и через него вызываем терминал psql 
Выйти из консоли psql можно командой \q 

Итак, заходит в psql под пользователем postgres (должны увидеть вот такое: postgres=#)
Создаем базу данных с рандомным именем: CREATE DATABASE test; Здесь CREATE DATABASE - оператор создания базы данных, test - собственно название базы данных. 
Для имен БД есть свои правила, так что если введете что-то не так, вам сообщат. Самое основное - нельзя пользоваться дефисами
Если введете CREATE DATABASE test-1; то получите вот такую хрень 
ERROR:  syntax error at or near "-"
LINE 1: CREATE DATABASE test-1;

Чтобы посмотреть список баз данных всех пользователей можно воспользоваться командой \l (или полный вариант \list, без разницы). Чтобы выйти оттуда жмем q

Чтобы посмотреть всех пользователей постгрес, набираем вот такое вот: \du

Создаем таблицу: CREATE TABLE mytable();
Чтобы посмотреть таблицы, имеющиеся в БД, набираем \dt

Теперь разбираемся с подставой с паролем. Для адекватной работы пользователю постгрес нужно задать пароль, по умолчанию у суперюзера postgres его нет, что, в частности, "затрудняет" подключение к БД из редактора кода. 
Нужна следующая команда: ALTER USER postgres WITH PASSWORD 'postgres';
Здесь для пользователя postgres задается пароль 'postgres'

По причине наличия минтайной связи между пользователями постреса и аккаунтами линукса крайне рекомендуется использовать идентичные имена. 
К примеру, создать аккаунт в линуксе с логином karnozavr666 и аккаунт посгрес с логином karnozavr666 (не забываем про пароль) и заходить сразу через него

//Шпаргалка:
Вход в консоль: sudo -u postgres psql
Выход из консоли: \q
Показать всех пользователей: \du
Показать все базы данных: \l
Зайти в базу данных: \c nameDB
Показать таблицы в базе данных: \dt

************************************************************************
// При работе с postgres помним два важных правила:
1. Операторы пишутся капсом (да, это выглядит как абьюз), можно писать lower case (строчными буквами), но best practics, все дела...
2. В конце инструкций всегда нужно ставить точку с запятой (иначе не заработает) - ; 

 P.S. Оператор - это некий набор символов (слово или несколько слов), на первый вид бессвязный, который говорит постресу что мы вообще от него хотим (SELECT, FROM, WHERE, JOIN и др.). Операторы заранее предустановлены разработчиками постгреса.
      Между операторами есть данные, с которыми мы работаем - это операнды. 

 P.S.S. Инструкция - строка кода, которая делает что-то осмысленное (в идеале).

 Пример: вот так выглядит поиск всех строк в столбце name в таблице users: SELECT name FROM users; (это одна инструкция, где SELECT и FROM - операторы, name и users - операнды, точка с запятой означает конец инструкции)

************************************************************************
Подключение postgres в VS CODE

Ставим расширение PostgreSQL (автор Chris Kolkman, там сейчас порядка миллиона скачиваний)
После этого в левой верхней части редактора появится кружка со слоном
Жмякаем на кружку, и затем на плюсик который появится. 
В верхней части редактора откроется небольшое окошко, в котором будет любезно предложено совершить 7 осмысленных действий по порядку:
1. Указать IP адрес хозяина (хоста). При открытии БД, развернутой локально, нужно прописать localhost - 127.0.0.1
2. Ввести пользователя postgres
3. Ввести пароль для этого пользователя
4. Ввести порт, на котором крутится postgres (если вы не лазили в конфигах, то по умолчанию это будет 5432)
5. Указать Standard Connection
6. Выбрать из предложенного списка БД (если выбора нет, то расширение не может подключиться к постгресу)
7. Придумать любое на ваш выбор имя, которое будет отображаться для помойки, которую вы открываете

Скипнуть окошечко можно на любом шаге на клавишу Esc

************************************************************************
Основные действия при работе с postgres
В целях наглядности здесь и далее мы займемся анализом вечно зеленой темы - отношалок. Создадим БД, которая будет отражать отношения между людьми. 
/////

Создание базы данных 
CREATE DATABASE relationship;
Здесь CREATE DATABASE указывает на создание базы данных, relationship - собственно ее название. Вроде, все очевидно.

Создаем первую таблицу, но перед этим немного поговорим о типах данных. 
В постгрес есть разные типы данных, самые распространенные из них следующие:
VARCHAR(255) - строка длиной в определенное количество символов, число которых указывается в скобках
TEXT - строка большой длины 
INT - целые числа
BOOL- true или false

Почитать подробней о типах данных можно вот здесь: https://neon.tech/postgresql/postgresql-tutorial/postgresql-data-types

Создание таблицы (перед этим не забываем коннектиться к нашей БД)
relationship=# CREATE TABLE women(
relationship(# id SERIAL PRIMARY KEY,
relationship(# name VARCHAR(255),
relationship(# husband BOOL,
relationship(# children BOOL,
relationship(# lovers BOOL
relationship(# );

Все указанное выше - одна инструкция, ее можно прописывать в несколько строк для удобства, главное не ошибиться по пути. 

Для каждой сущности нам нужен уникальный идентификатор, как правило, это отдельный айдишник (по сути это искусственная колонка). Однако, в качестве идентификатора можно использовать другое значение, если мы на 100% уверены что оно будет уникальным.
Если бы женщины в таблице были бы астрологами или представителями какой-либо другой древней профессии, то в качестве идентификатора можно было бы использовать номер заказа. 
Здесь для сущности женщина используется id с указанием SERIAL PRIMARY KEY. Отличение идентификатора от первичного ключа в том, что первичный ключ может быть только один в таблице, тогда как идентификаторов может быть несколько. 
SERIAL - это обычный INTEGER, только с автоинкрементом, т.е. при добавлении каждой новой записи генерируется новое значение, которое больше предыдущего на единицу.
PRIMARY KEY - означает, что добавить значение, которое уже есть в таблице, нельзя. 
Чуть позже мы разберет этот момент подробней.

Проверим, что мы насоздавали (\dt)

         List of relations
 Schema | Name  | Type  |  Owner   
--------+-------+-------+----------
 public | women | table | postgres
(1 row)

Должен получиться вот такой вывод в консоль (да, инфу в консоли можно сверстать чтобы красиво выглядело, спасибо разрабам посгреса)

Чтобы вывести описание таблицы, пишем: \d women

                                    Table "public.women"
  Column  |          Type          | Collation | Nullable |              Default              
----------+------------------------+-----------+----------+-----------------------------------
 id       | integer                |           | not null | nextval('women_id_seq'::regclass)
 name     | character varying(255) |           |          | 
 husband  | boolean                |           |          | 
 children | boolean                |           |          | 
 lovers   | boolean                |           |          | 
Indexes:
    "women_pkey" PRIMARY KEY, btree (id)

Дока по созданию таблиц: https://postgrespro.ru/docs/postgresql/16/tutorial-table

Добавим в таблицу первые данные: INSERT INTO women (id, name, husband, children, lovers) VALUES (DEFAULT, 'Вера', TRUE, TRUE, TRUE);
INSERT INTO указывает на операцию вставки, затем следует название таблицы, в скобках указываются столбцы, затем прописываем VALUES и значения для столбцов. Для айдишника всегда указываем DEFAULT (позже рассмотрим почему)

/////
Базовый поиск 

Чтобы посмотреть, что содержится в таблице, нужно воспользоваться поиском.

SELECT * FROM women;

Оператор SELECT указывает на операцию поиска, FROM - говорит, в какой таблице искать, * - найти все что есть (неоптимально, т.к. при добавлении новых данных результат будет меняться)

 id | name | husband | children | lovers 
----+------+---------+----------+--------
  1 | Вера | t       | t        | t
(1 row)

Оптимальней производить поиск по отдельным колонкам:
SELECT name FROM women; 

Дока по добавлению данных в таблицу: https://postgrespro.ru/docs/postgresql/16/tutorial-populate

Теперь рассмотрим удаление строк

Добавим женщину с поэтическим турецким именем Наташа
INSERT INTO women (id, name, husband, children, lovers) VALUES (DEFAULT, 'Наташа',  true, true, true);

... и выпнем ее из таблицы: 
DELETE FROM women WHERE name = 'Наташа';


ЗАДАНИЕ: добавить в таблицу женщин с именами Надежда и Любовь 

/////
Поиск по условию 

Для поиска с условием используется оператор WHERE в сочетании с логическими операторами AND, OR, HOR, NOT и операторами =, >, <, >=, <=

Рассмотрим просто пример: мы хотим найти всех женщин, у которых нет мужа. Вот сама таблица 

 id |  name   | husband | children | lovers 
----+---------+---------+----------+--------
  1 | Вера    | t       | t        | t
  2 | Надежда | t       | f        | t
  3 | Любовь  | f       | f        | t
(3 rows)

SELECT * FROM women WHERE husband = FALSE; 

  id   |  name  | husband | children | lovers 
-------+--------+---------+----------+--------
 3 | Любовь | f       | f        | t
(1 row)


Теперь мы найдем женщин, у которых есть и муж, и любовники 

SELECT * FROM women WHERE husband = TRUE AND lovers = TRUE;

 
 id |  name   | husband | children | lovers 
----+---------+---------+----------+--------
  1 | Вера    | t       | t        | t
  2 | Надежда | t       | f        | t
(2 rows)



Сейчас мы подошли к тому, что можем решать первые задачи

1. SQL Grasshopper: Select Columns
https://www.codewars.com/kata/582365c18917435ab3000020/train/sql

Просто нужно вывести несколько колонок, всего-то лишь (хз почему кузнечик)

2. https://leetcode.com/problems/recyclable-and-low-fat-products/description/
В ней нужно найти все продукты, в которых low_fats = 'Y' и recyclable = 'Y';
Не забываем в качестве языка выбрать PostgreSQL

3. Register for the Party (SQL for Beginners #3)
https://www.codewars.com/kata/590cc86f7557c0494000007e/train/sql

Обычная операция вставки, обратите внимание на код - в верхней строке уже стоит INSERT, нижнюю строку с поиском оставляем

4. Find all active students
https://www.codewars.com/kata/5809b9ef88b750ab180001ec/train/sql

Нужно составить простой запрос с WHERE, обращаем внимание, что в колонке IsActive хранится не сам тип boolean, а 1 или 0 

5. Collect Tuition (SQL for Beginners #4)
https://www.codewars.com/kata/5910b0d378cc2ba91400000b/train/sql

Выводим все колонки таблицы (в том числе колонку с данными об оплате), где строки соответствую условию

6. Adults only (SQL for Beginners #1)
https://www.codewars.com/kata/590a95eede09f87472000213/train/sql

Несложная задача на оператор WHERE (выполняет только если вам больше 18)

7. On the Canadian Border (SQL for Beginners #2)
https://www.codewars.com/kata/590ba881fe13cfdcc20001b4/train/sql

Нужно верно составить условие с использованием логических операторов


//////
Группировка данных при выводе

Вначале добавим еще одну колонку в таблицу
ALTER TABLE women ADD COLUMN age INTEGER;

Схематично описать это можно следующим образом:
Оператор ALTER TABLE => название таблицы => оператор ADD COLUMN => название новой колонки => тип данных 

Отлично, теперь нужно занести новые данные в таблицу

UPDATE women SET age = 22 WHERE name = 'Вера';
Смотритесь внимательно в эту строку и разберите ее сами, добавьте возраст для Надежды 25 лет, возраст Любви - 23 года

Должно получиться вот так

 id |  name   | husband | children | lovers | age 
----+---------+---------+----------+--------+-----
  1 | Вера    | t       | t        | t      |  22
  2 | Надежда | t       | f        | t      |  25
  3 | Любовь  | f       | f        | t      |  23
(3 rows)


Для группировки применяется оператор ORDER BY, который по умолчанию сортирует по возрастанию
SELECT * FROM women ORDER BY age;

 id |  name   | husband | children | lovers | age 
----+---------+---------+----------+--------+-----
  1 | Вера    | t       | t        | t      |  22
  3 | Любовь  | f       | f        | t      |  23
  2 | Надежда | t       | f        | t      |  25
(3 rows)

Для группировки по убыванию используется оператор DESC
SELECT * FROM women ORDER BY age DESC;

 id |  name   | husband | children | lovers | age 
----+---------+---------+----------+--------+-----
  2 | Надежда | t       | f        | t      |  25
  3 | Любовь  | f       | f        | t      |  23
  1 | Вера    | t       | t        | t      |  22
(3 rows)

На самом деле, для группировки по возрастанию тоже есть свой оператор - ASC, но он прошит по умолчанию:
SELECT * FROM women ORDER BY age ASC;

 id |  name   | husband | children | lovers | age 
----+---------+---------+----------+--------+-----
  1 | Вера    | t       | t        | t      |  22
  3 | Любовь  | f       | f        | t      |  23
  2 | Надежда | t       | f        | t      |  25
(3 rows)

При группировке можно задать лимит на количество выводимых записей:
SELECT * FROM women ORDER BY age LIMIT 2;

 id |  name  | husband | children | lovers | age 
----+--------+---------+----------+--------+-----
  1 | Вера   | t       | t        | t      |  22
  3 | Любовь | f       | f        | t      |  23
(2 rows)


При выводе можно пропустить определенное число первых строк:
SELECT * FROM women ORDER BY age OFFSET 1;

 id |  name   | husband | children | lovers | age 
----+---------+---------+----------+--------+-----
  3 | Любовь  | f       | f        | t      |  23
  2 | Надежда | t       | f        | t      |  25
(2 rows)


Теперь зададимся вопросом: что если, мы хотим найти только уникальные строки. 
К примеру, нам нужно составить справочник всех женских имен, которые есть в таблице.
Для наглядности, добавим в таблицу еще одну Надежду: INSERT INTO women (id, name, husband, children, lovers, age) VALUES (DEFAULT, 'Надежда', FALSE, FALSE, FALSE, 18);

Теперь поищем все имена: SELECT name FROM women;
  name   
---------
 Вера
 Надежда
 Любовь
 Надежда
(4 rows)


Ммм... отлично, мы вывели весь столбец name. И как избавиться от дублей? Здесь поможет оператор DISTINCT
SELECT DISTINCT name FROM women;

  name   
---------
 Любовь
 Вера
 Надежда
(3 rows)

И еще один кейс, который встречается достаточно часто - мы хотим изменить название самого столбца. Используется для этого оператор AS
SELECT name AS women_name, age AS women_age FROM women;

 women_name | women_age 
------------+-----------
 Вера       |        22
 Надежда    |        25
 Любовь     |        23
 Надежда    |        18
(4 rows)

Сейчас это конечно выглядит бессмысленно, но потом, когда мы будем формировать новый столбец при выводе нам это очень пригодится (при подсчете разных значений, при объединении нескольких таблиц и др.)

ЗАДАЧИ:
8. https://www.codewars.com/kata/5809508cc47d327c12000084/train/sql
Все просто, здесь нужно вывести все строчки, где человек старше 50 лет и сортировать по убыванию

9. https://leetcode.com/problems/big-countries/description/
Тоже ничего сложного, просто нужно верно составить условие

10. Easy SQL - Ordering
https://www.codewars.com/kata/593ed37c93350098d600001d/train/sql

Задача с группировкой по убыванию

11. SQL Basics: Simple DISTINCT
https://www.codewars.com/kata/58111670e10b53be31000108/train/sql

Просто нужно вывести все уникальные возраста, обратите внимание, что менять название столбца не нужно - в описании указано age (distinct), но нужно просто age

************************************************************************
// Разница между идентификатором и первичным ключом 

Выведем нашу таблицу: SELECT * FROM women;

 id |  name   | husband | children | lovers | age 
----+---------+---------+----------+--------+-----
  1 | Вера    | t       | t        | t      |  22
  2 | Надежда | t       | f        | t      |  25
  3 | Любовь  | f       | f        | t      |  23
  4 | Надежда | f       | f        | f      |  18
(4 rows)

Как видим, айдишники располагаются в строгом порядке от 1 до 4, при этом когда мы добавляли новые строки всегда в качестве значения id указывали DEFAULT
За такой порядок отвечает тип данных SERIAL. Это обычное число (INTEGER), которое при добавлении значения DEFAULT увеличивает предыдущее значение на единицу. 
При работе с SERIAL мы может прописать отдельное правило для определения последовательности, но нам пока это не важно. 
Плюс к этому на этапе создания таблицы мы может задать первое дефолтное значение для последовательности. 
Вообще, по правде, обычно используется заранее сгенерированный айдишник типа INTEGER...

Теперь удалим любовь из нашей жизни:
DELETE FROM women WHERE name = 'Любовь';

SELECT * FROM women;

 id |  name   | husband | children | lovers | age 
----+---------+---------+----------+--------+-----
  1 | Вера    | t       | t        | t      |  22
  2 | Надежда | t       | f        | t      |  25
  4 | Надежда | f       | f        | f      |  18
(3 rows)

У нас удалилась запись с id = 3

... и теперь мы снова захотели влюбиться. 
INSERT INTO women (id, name, husband, children, lovers, age) VALUES (DEFAULT, 'Любовь', FALSE, FALSE, TRUE, 23);

SELECT * FROM women;

 id |  name   | husband | children | lovers | age 
----+---------+---------+----------+--------+-----
  1 | Вера    | t       | t        | t      |  22
  2 | Надежда | t       | f        | t      |  25
  4 | Надежда | f       | f        | f      |  18
  5 | Любовь  | f       | f        | t      |  23
(4 rows)

И тут мы поняли, что в одну реку нельзя войти дважды. 
При использовании типа данных SERIAL расчет нового значения всегда ведется от предыдущего, т.е. от последнего который есть, и в данном случае это 4

Итак, с SERIAL разобрались. Зачем же нужен PRIMARY KEY?

Свяжемся с новой женщиной и попробуем добавить ей значение id из уже существующих. 

INSERT INTO women (id, name, husband, children, lovers, age) VALUES (5, 'Светка', FALSE, TRUE, TRUE, 34);

Получим вот такую ошибку: 
ERROR:  duplicate key value violates unique constraint "women_pkey"
DETAIL:  Key (id)=(5) already exists.

PRIMARY KEY отвечает за то, чтобы в столбце таблицы не было дублирующий значений.
Эх, не видать нам светки как своих ушей. Такая женщина пропадает...


************************************************************************
// Агрегатные функции 

 На практике часто возникают ситуации, когда нужно совершить операцию сразу над несколькими строками, к примеру определить средний возраст женщин
 Тут на помощь спешат агрегатные функции (видимо, их название происходит от слова агрегатор, хе-хе)
 Агрегатная функция совершает действия сразу над несколькими строками и выплевывает результат 

 В постгресе есть 11 агрегатных функций:

 AVG - находит среднее значение

 SUM - находит сумму значений

 MIN - находит минимальное значение

 MAX - находит максимальное значение

 COUNT(*) - находит количество строк в запросе (вместо звездочки подставляем название колонки)

 COUNT(expression) - вместо слова expression подставляете свое значение, и выплевывается результат, где для выражения нет значения Nullable

 BIT_AND - операция логического И 

 BIT_OR - операция логического ИЛИ 

 BOOL_AND - логическое умножение для типа BOOL 

 BOOL_OR - логическое сложение для типа BOOL

 STRING_AGG(expression, delimiter): соединяет с помощью delimiter все текстовые значения из expression в одну строку

 Сейчас нас интересуют первые пять агрегатных функций, остальные пока просто даны для справочник

 ВАЖНО: если нет строк для расчета, то все функции, за исключением COUNT(*), возвращают NULL
 Также нужно отметить, что агрегатные функции используются до оператора WHERE, что вполне логично, т.к. условие выполняется после того, как мы поработали со строками
 Исключение - подзапросы, которые могут быть внутри WHERE (с подзапросами разберемся чуть позже, пока просто узнает, что такое явление существует)

 Обращаем внимание, что функции работают только с определенными типами данных, какими именно - можете погуглить

 Почитать подробней можно здесь: https://postgrespro.ru/docs/postgresql/16/tutorial-agg

 Теперь немного практики
 SELECT COUNT(name) FROM women WHERE name = 'Надежда';

 count 
-------
     2
(1 row)

Обратите внимание на сам запрос - функции COUNT нужно скормить название конкретной колонки, и затем поставить условие
Так, вот так запрос будет ошибочным и не вернет нужной информации: SELECT COUNT('Надежда') FROM women;

Возможно при помощи COUNT(*) подсчитать общее количество строк в таблице:
SELECT COUNT(*) FROM women;

 count 
-------
     4
(1 row)

Определим количество уникальных имен
SELECT COUNT(DISTINCT name) AS unique_name FROM women;

 unique_name 
-------------
           3
(1 row)

Название колонки при выводе - count, что не всегда информативно. Воспользуемся оператором AS
SELECT COUNT(name) AS quantity_women FROM women WHERE name = 'Надежда';

 quantity_women 
----------------
              2
(1 row)

ЗАДАНИЕ: потренируйтесь с функциями AVG, MIN, MAX, SUM на колонке age

************************************************************************
// Продолжаем рассматривать группировку

Мощный способ группировки представляет оператор GROUP BY. В отличие от ORDER BY, он вычленяет группы строк, а не сортирует их по возрастанию или убыванию
SELECT name FROM women GROUP BY name;

  name   
---------
 Любовь
 Вера
 Надежда
(3 rows)


Одна из типовых задач (как в бизнесовом коде, так и при решении задач) сводится к тому, что нужно с использованием COUNT  GROUP BY хитрым образом поискать по двум колонкам сразу 
Для демонстрации возможностей связки этих операторов добавим новый столбец, содержащий информацию о венерических заболеваниях
ALTER TABLE women ADD COLUMN venereal_diseases VARCHAR(255);

Хорошо (хотя ничего хорошего), напишем кто чем болеет 
Женщины с любовниками страдают гепатитом с, без любовников - хламидиозом 
UPDATE women SET venereal_diseases = 'гепатит с' WHERE lovers = TRUE;
UPDATE women SET venereal_diseases = 'хламидиоз' WHERE lovers = FALSE;

 id |  name   | husband | children | lovers | age | venereal_diseases 
----+---------+---------+----------+--------+-----+-------------------
  1 | Вера    | t       | t        | t      |  22 | гепатит с
  2 | Надежда | t       | f        | t      |  25 | гепатит с
  5 | Любовь  | f       | f        | t      |  23 | гепатит с
  4 | Надежда | f       | f        | f      |  18 | хламидиоз
(4 rows)

Отлично, идем дальше. Мы хотим вывести все группы заболеваний, и подсчитать количество болеющих ими женщин, плюс сгруппировать по убыванию

SELECT venereal_diseases, COUNT(name) AS cases FROM women GROUP BY venereal_diseases ORDER BY cases DESC;

 venereal_diseases | cases 
-------------------+-------
 гепатит с         |     3
 хламидиоз         |     1
(2 rows)

Разбираемся, что произошло. 

Мы нашли все строки колонки venereal_diseases, подсчитали количество имен (и дали наименование этой колонке), сгруппировали по венерическим заболеваниям 
   и при группировке значения столбца cases подсчитались для каждой группы, затем сортировали по убыванию 

Обратите внимание на то, что наличие агрегатной функции в этом случае требует группировки
Вот такой запрос будет ошибочным: 
SELECT venereal_diseases, COUNT(name) AS cases FROM women;
ERROR:  column "women.venereal_diseases" must appear in the GROUP BY clause or be used in an aggregate function

Если бы мы просто считали количество строк, то проблем бы не было:
SELECT COUNT(venereal_diseases) FROM women;

 count 
-------
     4
(1 row)

Но когда в запросе мы добавляем поиск еще одной колонки, то требуется обязательно группировка, иначе постгрес сойдет с ума 
SELECT venereal_diseases, COUNT(name) AS cases FROM women - здесь постгрес находит и колонку с заболеваниями, и общее число женщин, и эта вся богадельна нуждается в группировке


На текущий момент мы умеет создавать таблицы и производить несложные операции поиска, в т.ч. с использованием агрегатных функций
Однако, этого недостаточно для запросов, когда нужно не просто что-то найти и вычислить, но и фильтрануть результат 
Для фильтрации результата используется оператор HAVING, который часто используется с функцией COUNT(*)

SELECT venereal_diseases, COUNT(name) AS cases FROM women GROUP BY venereal_diseases HAVING COUNT(*) > 1;

 venereal_diseases | cases 
-------------------+-------
 гепатит с         |     3
(1 row)

Здесь COUNT после оператора HAVING подсчитывает те строки, которые уже сгруппированы, а не считает все что есть как в начале запроса

Отличия между HAVING и WHERE:

           Оператор HAVING 	                                   Оператор WHERE
Проверяет условие для группы строк 	             Проверяет условие для каждой строки отдельно
Используется с агрегатными функциями 	           Нельзя использовать с агрегатными функциями
Выполняется после оператора GROUP BY	           Выполняется перед оператором GROUP BY

ЗАДАЧИ:

13. Number of Unique Subjects Taught by Each Teacher
https://leetcode.com/problems/number-of-unique-subjects-taught-by-each-teacher/description/

Базовая задача на GROUP BY

14. Classes More Than 5 Students
https://leetcode.com/problems/classes-more-than-5-students/description/

Базовый пример фильтрации - найдем все строки с классами, сгруппируем их и фильтранем с использованием COUNT

15. Duplicate Emails
https://leetcode.com/problems/duplicate-emails/description/

Для решения задачи нужно найти все строки email, сгруппировать их и отфильтровать с использованием HAVING и COUNT (именно в таком порядке)

16. SQL Basics: Simple MIN / MAX
https://www.codewars.com/kata/581113dce10b531b1d0000bd/train/sql

Простая задача на агрегатные функции и оператор AS 

17. SQL Basics: Simple SUM
https://www.codewars.com/kata/58110da0009b4f7ef80000ad/train/sql

Используем агрегатную функцию SUM и оператор AS


************************************************************************
// Функции 

Ранее мы пощупали агрегатные функции, которые оперируют группой значений. 
А если нам нужно просто совершить действие над одним значением?
Для этого существуют разные готовые решения
Примеры:

ROUND - округление числа
FLOOR - округление числа вниз
CEILING - округление числа вверх
TRUNCATE - позволяет отбросить определенное число знаков после запятой

ЗАДАЧИ:
14. Easy SQL: Rounding Decimals
https://www.codewars.com/kata/594a6133704e4daf5d00003d/train/sql

Нюанс в том, что когда мы применили функцию к значению, нужно отдельно обозначить имя колонки (оператор AS)

16. Easy SQL: LowerCase
https://www.codewars.com/kata/594800ba6fb152624300006d/train/sql

Самостоятельно узнайте в гугле, какую функцию нужно применить

17. SQL Basics: Mod
https://www.codewars.com/kata/594a9592704e4d21bc000131/train/sql

В этой задаче речь идет о функции MOD(), которая возвращает остаток от деления

18. Easy SQL: Convert to Hexadecimal
https://www.codewars.com/kata/594a50bafd3b7031c1000013/train/sql

Нужно перевести числа из десятичной системы счисления в шестнадцатеричную 

19. Easy SQL: Square Root and Log
https://www.codewars.com/kata/594a691720ac16a544000075/train/sql

Если вдруг не знаете что такое логарифм (кусь) - скипайте

21. Find Followers Count
https://leetcode.com/problems/find-followers-count/description/

Вот мы и подошли к интересной задачке. Для ее решения нужно представлять структуру запроса.
В данном случае - получить строки (с использованием агрегатной функции), сформировать группы и отсортировать их 


************************************************************************
Оператор IN 

IN позволяет фильтровать по нескольким значениям сразу. Итак, говорим и показываем 

INSERT INTO women (id, name, husband, children, lovers, venereal_diseases) VALUES (DEFAULT, 'Карина', TRUE, FALSE, TRUE, 'трихомониаз');

 id |  name   | husband | children | lovers | age | venereal_diseases 
----+---------+---------+----------+--------+-----+-------------------
  1 | Вера    | t       | t        | t      |  22 | гепатит с
  2 | Надежда | t       | f        | t      |  25 | гепатит с
  5 | Любовь  | f       | f        | t      |  23 | гепатит с
  4 | Надежда | f       | f        | f      |  18 | хламидиоз
  6 | Карина  | t       | f        | t      |     | трихомониаз
(5 rows)

Сейчас мы хотим женщин, которые страдают гепатитом с или трихомонизазом: 
SELECT name, venereal_diseases FROM women WHERE venereal_diseases IN('гепатит с', 'трихомониаз');

  name   | venereal_diseases 
---------+-------------------
 Вера    | гепатит с
 Надежда | гепатит с
 Любовь  | гепатит с
 Карина  | трихомониаз
(4 rows)

************************************************************************
Сочетание  запросов
В некоторых случаях нам нужно сделать несколько запросов и обработать их совместно. Для этого существуют сочетания запросов, их три:
1. UNION - объединение
2. INSERSECTION - пересечение
3. EXCEPT - исключение

Да-да, кто-то уже мог догадаться, что это операции над множествами. 

SELECT name FROM women WHERE venereal_diseases = 'гепатит с' 
UNION 
SELECT name FROM women WHERE venereal_diseases = 'хламидиоз'; 

  name   
---------
 Вера
 Любовь
 Надежда
(3 rows)

Выглядит, конечно же, бесполезно. К тому же, по дефолту дублирующие строки выпиливаются. Чтобы вывести все шапито, добавляем оператор ALL 
SELECT name FROM women WHERE venereal_diseases = 'гепатит с' 
UNION ALL 
SELECT name FROM women WHERE venereal_diseases = 'хламидиоз'; 

  name   
---------
 Вера
 Надежда
 Любовь
 Надежда
(4 rows)

Смысла конечно же мало прибавилось, но что если у нас не одна, а, скажем, парочка таблиц? Как и всегда, говорим и показываем

CREATE TABLE men (id SERIAL PRIMARY KEY, name VARCHAR(255) NOT NULL);

INSERT INTO men (id, name) VALUES (DEFAULT, 'Генерал Кастер');

 id |      name      
----+----------------
  1 | Генерал Кастер
(1 row)

SELECT name FROM women UNION ALL SELECT name FROM men;

      name      
----------------
 Вера
 Надежда
 Любовь
 Надежда
 Карина
 Генерал Кастер
(6 rows)

Прекрасно, теперь мы может объединять данные из разных таблиц

Оператор UNION собирает все строки из первого запроса и из второго запроса. 
INTERSECT ведет себя другим образом - в итоговую выборку попадут только общие строки из двух запросов. 
Т.е., если строка есть и в первом запросе, и во втором - это и будет пересечением.

ALTER TABlE women ADD COLUMN personality_disorder VARCHAR(255);

INSERT INTO women (id, name, husband, children, lovers, age, venereal_diseases, personality_disorder) VALUES (DEFAULT, 'Вика', FALSE, FALSE, TRUE, 26, 'кандидоз', 'истерик');

 id |  name   | husband | children | lovers | age | venereal_diseases | personality_disorder 
----+---------+---------+----------+--------+-----+-------------------+----------------------
  1 | Вера    | t       | t        | t      |  22 | гепатит с         | 
  2 | Надежда | t       | f        | t      |  25 | гепатит с         | 
  5 | Любовь  | f       | f        | t      |  23 | гепатит с         | 
  4 | Надежда | f       | f        | f      |  18 | хламидиоз         | 
  6 | Карина  | t       | f        | t      |     | трихомониаз       | 
  7 | Вика    | f       | f        | t      |  26 | кандидоз          | истерик
(6 rows)



ALTER TABLE men ADD COLUMN personality_disorder VARCHAR(255);

UPDATE men SET personality_disorder = 'социопат'  WHERE name = 'Генерал Кастер';


 id |      name      | personality_disorder 
----+----------------+----------------------
  1 | Генерал Кастер | cоциопат
(1 row)


Так вот. Теперь мы может попробовать найти расстройства личности, которыми страдают на текущий момент только женщины. 
Оператор EXCEPT покажет нам только те строки, которые есть в первой выборке, и при этом отсутствуют во второй
Поехали

SELECT personality_disorder FROM women EXCEPT SELECT personality_disorder FROM men;

 personality_disorder 
----------------------
 
 истерик
(2 rows)

Хмм... получилось две строки, и одна из них пуста. Дело в том, что при создании колонки personality_disorder мы не указывали NOT NULL
В таблице мужчин нет значения этой колонки как NULL, поэтому оно считается за уникальное. Отсутсвие результата - тоже результат. Наверное...

Наконец, INTERSECT. С помощью этого оператора можно найти общие строки, т.е. только те, которые совпадают 

INSERT INTO men (id, name, personality_disorder) VALUES (DEFAULT, 'Сальвадор Дали', 'истерик');

SELECT personality_disorder FROM women 
INSERSECT
SELECT personality_disorder FROM men;

 personality_disorder 
----------------------
 истерик
(1 row)

Здесь мы нашли расстройства личности, которые присутствуют в обеих таблицах 

По умолчанию значение в колонках может быть null, но если мы категорически против этого - прописываем NOT NULL

P.S. Расстройство личности - вид психического расстройства, при котором больные ведут себя всегда неадекватно, и это не лечится
Нас интересуют (потом узнаете почему) исключительно расстройства позбудимого типа, их 4: 
1. Антисоциальное расстройство 
2. Нарциссическое расстройство 
3. Истерическое расстройство 
4. Пограничное расстройство 

По мере изучения постгреса мы узнает об этом много нового, а пока порешаем задачки 

ЗАДАЧИ:
22. Finding Products Matching All Selected Tags
https://www.codewars.com/kata/67741444c77444b19e8b5223/train/sql

Здесь нужно связать результаты двух запросов с использованием пересечения, и затем сгруппировать по убыванию

23. Invalid Tweets
https://leetcode.com/problems/invalid-tweets/description/

Немного расслабимся, просто найдите функцию подсчета символов в строке и верно примените ее в условии

24. Triangle Judgement
https://leetcode.com/problems/triangle-judgement/description/

Немного отвлечемся. Для решения задачи самостоятельно изучите, как работает оператор CASE 

25. Calculate Special Bonus
https://leetcode.com/problems/calculate-special-bonus/description/

Продолжаем тему с оператором CASE (не забудьте упорядочить данные по айдишнику)

26. Find Customer Referee
https://leetcode.com/problems/find-customer-referee/description/

Нужно составить условие с проверкой на null (обратите внимание, что оператор AND работает не всегда так, как мы о нем думаем)


************************************************************************
ВИДЫ СВЯЗЕЙ

Сейчас займемся тем, что вы все долго ждали - выясним, кто чей любовник 
Для этого внесем изменения в колонку lovers. Сейчас она отражает только true или false
Нам же нужно конкретное указание на любовников
Сейчас у нас есть сущность женщины и сущность мужчины 
Нам нужно установить связь между ними 
Самые наблюдательные из вас могли заметить, что lovers - это множественное число 
... и значит, что любовник может быть далеко не один 
Для связи между сущностями мы будет пользоваться их уникальной колонкой - id 
Наверное, первое, что приходит в голову -  для каждой женщины у нас будет заведен массив с айдишниками
 где каждый айдишник принадлежит определенному мужчине. Попробуем разобрать эту логику

Но, для этого нам нужно поменять данные в уже существующей колонке lovers 
Для изменения типа данных в колонке используется следующая команда:
ALTER TABLE women ALTER COLUMN lovers TYPE INTEGER[];

Конечно же, не все так просто:
ERROR:  column "lovers" cannot be cast automatically to type integer[]
HINT:  You might need to specify "USING lovers::integer[]".

Колонка lovers уже заполнена булевыми значениями, и нужно явно указать постгресу, как их преобразовать
Делаем следующее
Сбрасываем все текущие значения в колонке:
ALTER TABLE women ALTER lovers DROP DEFAULT;

Меняем тип:
ALTER TABLE women ALTER lovers type INTEGER[] USING ARRAY[lovers];

Здесь type INTEGER[] - это собственно указание на нужный тип, USING ARRAY[lovers] - указание на то, что нам нужен именно массив 
Не самый очевидный синтаксис, но и менять тип данных в колонках вы часто не будете 

 id |  name   | husband | children | lovers | age | venereal_diseases | personality_disorder 
----+---------+---------+----------+--------+-----+-------------------+----------------------
  1 | Вера    | t       | t        | {NULL} |  22 | гепатит с         | 
  2 | Надежда | t       | f        | {NULL} |  25 | гепатит с         | 
  5 | Любовь  | f       | f        | {NULL} |  23 | гепатит с         | 
  4 | Надежда | f       | f        | {NULL} |  18 | хламидиоз         | 
  6 | Карина  | t       | f        | {NULL} |     | трихомониаз       | 
  7 | Вика    | f       | f        | {NULL} |  26 | кандидоз          | истерик
(6 rows)


Да-да, именно так и выглядит массив в постгресе. 
И кстати не забывайте, что это не NULL, это пустой массив 
SELECT lovers FROM women WHERE lovers IS NOT NULL;

 lovers 
--------
 {NULL}
 {NULL}
 {NULL}
 {NULL}
 {NULL}
 {NULL}
(6 rows)

Не попадайтесь в такие очевидные ловушки...

А теперь поговорим о сложностях. То, что мы сейчас хотим сделать - называется "Массив внешних ключей"
Загвоздка в том, что массив как тип данных пришел из мира нереляционных баз - noSQL
Поэтому, при проектировании БД массивов, как правило, избегают 
Еще буквально лет десять тому назад постгрес не умел делать такие штуки
Теперь, хотя такая возможность есть, лучше действоват по-старинке

Для начала небольшое лирическое отступление. 
Есть три вида связей между сущностями
Вообще, сущность - это тип некого объекта. Т.е. это что-то отдельное, изолированное, и обязательно обладающее некими характеристиками
В нашем случае есть только пока две прям такие сущности - это женщины и мужчины 
Короче, сущность - отдельная коробка с барахлом
Вообще кстати venereal_diseases напрашивается в качестве самостоятельной сущности - наверное, это мы потом и сделаем (сущность гепатита с - звучит неплохо)

Так, значит, виды связей между сущностями:
1. Один к одному - One-to-One
2. Один ко многим - One-to-Many
3. Многие ко многим - Many-to-Many

Связь один к одному - сущность мужа и сущность жены. У одной жены может быть один муж, и наоорот. 
Один ко многим - одно расстройство личности может быть у разных женщин и мужчин, но каждый мужчина и каждая женщина могут иметь только одно расстройство
Многие ко многим - у женщин может быть множество любовников, а у любовников - множество женщин. 

И вот как раз нам нужно реализовать связь многие ко многим, когда речь заходит о любовниках 
Каноничный способ - создание промежуточной таблицы

Для начала полностью выпилим столбец lovers:
ALTER TABLE women DROP COLUMN lovers;

Отлично, теперь создадим промежуточную таблицу

CREATE TABLE women_lovers (
woman_id INTEGER REFERENCES women(id) ON DELETE CASCADE,
man_id INTEGER REFERENCES men(id) ON DELETE CASCADE,
PRIMARY KEY (woman_id, man_id)
);

Здесь для нас появились новые слова
REFERENCES - означает, что значение в колонке - ссылка на другую колонку, в данном случае ссылка на айдишник из другой таблицы
ON DELETE CASCADE - если удалится поле, на которое мы ссылаемся, то удалится и значение в таблице
В качестве первичного ключа здесь используются сразу две колонки (да, так можно было)

 woman_id | man_id 
----------+--------
(0 rows)

Теперь нужно вставить необходимые данные в таблицу 
INSERT INTO women_lovers (woman_id, man_id) VALUES (1, 1), (2,1), (4,1), (5,1), (6,1), (7,1), (6,2);

 woman_id | man_id 
----------+--------
        1 |      1
        2 |      1
        4 |      1
        5 |      1
        6 |      1
        7 |      1
        6 |      2
(7 rows)

Великолепно. Ситуация такая, что Генерал Кастер являестя любовником каждой женщины, а Сальвадор Дали - только женщины с id = 6
Тепер можно пояснить, что точно значит PRIMARY KEY (woman_id, man_id) - это когда мы создавали таблицу
Тут два первичных ключа сразу, и это значит, что уникальным должен быть не каждый из них в отдельности, а комбинация двух ключей
К примеру, айдишник 1 в колонке man_id повторяется неоднократно
А вот дубли из комбинации двух ключей невозможны:
INSERT INTO women_lovers (woman_id, man_id) VALUES (1,1);

ERROR:  duplicate key value violates unique constraint "women_lovers_pkey"
DETAIL:  Key (woman_id, man_id)=(1, 1) already exists.

Теперь зададимся вопросом: если мы попытается добавить id, которого нет в родительской таблице?
Ну, давайте попробуем, испытаем постгрес на прочность

ERROR:  duplicate key value violates unique constraint "women_lovers_pkey"
DETAIL:  Key (woman_id, man_id)=(1, 1) already exists.

Вот, это нам и нужно, идем дальше

Связь один ко многим. Предлагаю в целях практики сделать это на примере венерических заболеваний
Просто условимся, что женщина может болеть только одним заболеванием (потом это поправим)
Создадим еще одну таблицу

CREATE TABLE venereal_diseases (
 id SERIAL PRIMARY KEY,
 disease VARCHAR(255)
 );

INSERT INTO venereal_diseases (id, disease) VALUES (DEFAULT, 'гепатит с'),
(DEFAULT, 'хламидиоз'),
(DEFAULT, 'трихомониаз'),
(DEFAULT, 'кандидоз');


 id |   disease   
----+-------------
  1 | гепатит с
  2 | хламидиоз
  3 | трихомониаз
  4 | кандидоз
(4 rows)

Хмм... если бы в таблице с женщинами было бы много разных заболеваний, долго бы пришлось вручную переносить
А если бы там вообще было бы тысяч так десять строк... 
То, с чем мы столкнулись - ошибка в проектировании БД (ха-ха, можете не верить, но то сделано сейчас специально)
Представим, что у нас нет дефолтного списка заболеваний, и мы просто хотим создать таблицу, где будут для начала 
  хотя бы только те болезни, которыми уже страдают женщины

Начнем вот с такого хитрого примера:
INSERT INTO venereal_diseases (id, disease) VALUES 
(DEFAULT, (SELECT venereal_diseases FROM women WHERE name = 'Вера'));

 id |   disease   
----+-------------
  1 | гепатит с
  2 | хламидиоз
  3 | трихомониаз
  4 | кандидоз
  5 | гепатит с
(5 rows)

Вообще, подзапросы практически куда угодно запихивать 
Но мы сейчас не об этом
Дубли нам не нужны в таблице, поэтому давайте просто дропнет это безобразие
DROP TABLE venereal_diseases;

CREATE TABLE venereal_diseases (
 id SERIAL PRIMARY KEY,
 disease VARCHAR(255) NOT NULL UNIQUE
 );


NOT NULL вы знаете что такое, 
UNIQUE указывает на то, что не может быть дублей (каждая болезнь "уникальна"...)

Есть такая замечательная связка операторов, которая решает кучу проблем
INSERT INTO SELECT

Вот как можно применть:
INSERT INTO venereal_diseases(disease) SELECT DISTINCT venereal_diseases FROM women;

 id |   disease   
----+-------------
  3 | гепатит с
  4 | трихомониаз
  5 | кандидоз
  6 | хламидиоз
(4 rows)

Кстати, без оператора DISTINCT мы бы получили ошибку - при создании колонки мы прописали UNIQUE, 
   а гепатитом в таблице-доноре страдает явно не одна женщина
Обратите внимание, что мы не прописывали значение для колонки id - в этом кейсе оно автогенерируется,
   поскольку первичный ключ обязателен, и заполняется по дефолту

Теперь о том, почему айдшинки начинаются с цифры 3
Постгрес под капотом вначале собрал все найденные строки, присвоил им дефолтные айдишники, 
   затем отработал DISTINCT и уже после этого произошла вставка 

Так, вот теперь нужно пропустить фарш обратно через мясорубку
Нам нужно заметить данные в колонке venereal_diseases в таблице женщин на релевантные айдишники из нашей новой таблицы
Но, смена типа данных в уже заполненной колонке требует преобразования типов, и вот здесь все не так просто
Адекватный вариант в этом случае - создать временную колонку для переноса данных
ALTER TABLE women ADD COLUMN test_disease INTEGER;

... хотя куда их тестировать этих женщин, и без тестов все понятно 

Теперь введем вот такую хитрую команду 

UPDATE women w SET test_disease = v.id FROM venereal_diseases v
WHERE w.venereal_diseases = v.disease;

Буквы w и v - просто сокращения для названий таблиц, псевдонимы

 id |  name   | husband | children | age | venereal_diseases | personality_disorder | test_disease 
----+---------+---------+----------+-----+-------------------+----------------------+--------------
  5 | Любовь  | f       | f        |  23 | гепатит с         |                      |            3
  2 | Надежда | t       | f        |  25 | гепатит с         |                      |            3
  1 | Вера    | t       | t        |  22 | гепатит с         |                      |            3
  6 | Карина  | t       | f        |     | трихомониаз       |                      |            4
  7 | Вика    | f       | f        |  26 | кандидоз          | истерик              |            5
  4 | Надежда | f       | f        |  18 | хламидиоз         |                      |            6
(6 rows)


Выпилим первоначальную колонку:
ALTER TABLE women DROP COLUMN venereal_diseases;

... и переименуем временную:
ALTER TABLE women RENAME COLUMN test_disease TO venereal_disease;

Нет ничего более постоянного, чем временное, не так ли? (тяв)

 id |  name   | husband | children | age | personality_disorder | venereal_disease 
----+---------+---------+----------+-----+----------------------+------------------
  5 | Любовь  | f       | f        |  23 |                      |                3
  2 | Надежда | t       | f        |  25 |                      |                3
  1 | Вера    | t       | t        |  22 |                      |                3
  6 | Карина  | t       | f        |     |                      |                4
  7 | Вика    | f       | f        |  26 | истерик              |                5
  4 | Надежда | f       | f        |  18 |                      |                6
(6 rows)


И теперь настанет то, чего мы упорно добивались
У нас есть таблица с заболеваниями
В колонке venereal_disease в таблице с женщинами есть их айдишники
И мы хотим в явном виде узнать, кто чем болеет. Вперед

SELECT women.name, venereal_diseases.disease FROM women JOIN venereal_diseases 
ON
women.venereal_disease = venereal_diseases.id;

  name   |   disease   
---------+-------------
 Вера    | гепатит с
 Надежда | гепатит с
 Любовь  | гепатит с
 Карина  | трихомониаз
 Вика    | кандидоз
 Надежда | хламидиоз
(6 rows)

Вот она какая, магия постгреса (^_^)
... JOIN рассмотрим в следующей теме, но мы его уже успешно применили

ЗАДАНИЯ:
1. Создать таблицу с расстройствами личности, включить туда следующее:
"Антисоциальное расстройство"
"Нарциссическое расстройство"
"Истерическое расстройство"
"Пограничное расстройство"

Условия:
- таблица должна содержать две колонки - id (serial primary key) и personality_disorders (varchar(255))
- значения в колонке personality_disorders не должны быть null и должны быть уникальными (кстати, подумайте, чем primary key отличается от unique)

Результат:


 id |          disorder           
----+-----------------------------
  1 | Антисоциальное расстройство
  2 | Нарциссическое расстройство
  3 | Истерическое расстройство
  4 | Пограничное расстройство
(4 rows)

См. ниже про расстройства личности 

2. Добавить в таблицу мужчин айдишники их расстройств
Порядок действий:
- удалить текущий столбец personality_disorder из таблицы men
- создать новый столбец personality_disorder, значения которого должны быть ссылкой на поле id таблицы personality_disorders (с каскадным удалением)
- заполнить колонку данными (здесь данных мало, проще вручную сделать)

Результат:

 id |      name      | personality_disorder 
----+----------------+----------------------
  1 | Генерал Кастер |                    1
  2 | Сальвадор Дали |                    4
(2 rows)

Проверка на референсы:
UPDATE men SET personality_disorder = 10 WHERE name = 'Сальвадор Дали';
ERROR:  insert or update on table "men" violates foreign key constraint "men_personality_disorder_fkey"
DETAIL:  Key (personality_disorder)=(10) is not present in table "personality_disorders".

3. Аналогичным образом добавить данные о расстростве личности в таблицу women 

 id |  name   | husband | children | age | venereal_disease | personality_disorder 
----+---------+---------+----------+-----+------------------+----------------------
  5 | Любовь  | f       | f        |  23 |                3 |                     
  2 | Надежда | t       | f        |  25 |                3 |                     
  1 | Вера    | t       | t        |  22 |                3 |                     
  6 | Карина  | t       | f        |     |                4 |                     
  4 | Надежда | f       | f        |  18 |                6 |                     
  7 | Вика    | f       | f        |  26 |                5 |                    4
(6 rows)


4. И будут пути наши неисповедимы...
Нужно переделать связь женщин и венерических заболеваний на тип "Многие ко многим":
- создайте промежуточную таблицу women_venereal_diseases
  с двумя колонками:
  woman_id (референс на айдишники из таблицы women с каскадным удалением)
  disease_id (референс на айдишники из таблицы venereal_diseases с каскадным удалением)
  должно быть два первичных ключа - woman_id и disease_id
- перенесите туда данные из таблицы women (сделать это можно одной командой с использованием INSERT INTO SELECT)
- удалите колонку venereal_disease из таблицы women 

Результат:

 woman_id | disease_id 
----------+------------
        5 |          3
        2 |          3
        1 |          3
        6 |          4
        4 |          6
        7 |          5
(6 rows)

 id |  name   | husband | children | age | personality_disorder 
----+---------+---------+----------+-----+----------------------
  5 | Любовь  | f       | f        |  23 |                     
  2 | Надежда | t       | f        |  25 |                     
  1 | Вера    | t       | t        |  22 |                     
  6 | Карина  | t       | f        |     |                     
  4 | Надежда | f       | f        |  18 |                     
  7 | Вика    | f       | f        |  26 |                    4
(6 rows)

5. Реализуйте связь "Один к одному" на примере связи мужа и жены

- создайте таблицу husbands с полями id (serial primary key), name (varchar(255), не может быть null, но может быть неуникальным), wife_id(референс на айдишники из таблицы женщин)
- добавьте туда мужей с именами "Володя" (жена id = 2), "Игорек" (жена id = 6), "Аркаша" (жена id = 1)

Результат: 

 id |  name  | wife 
----+--------+------
  1 | Володя |    2
  2 | Игорек |    6
  3 | Аркаша |    1
(3 rows)


************************************************************************
Минутка душнилова 

Внесем ясность в некоторые термины. Мы использовали такие слова, как колонка, столбец, поле строка. 
Колонка и столбец - это то, что называется артибутом. 

Артибут - характеристика некого объекта и явления
Так, в таблице женщин сейчас есть следуюище атрибуты:
- id
- name
- husband
- children
- age
- personality_disorder

В других таблицах, соответственно, другие атрибуты 
Вопрос о том, хранить ли все атрибуты сущности в одной таблице, зависит от проектирования БД
Как правило, в рабочих проекта творится невообразимое шапито при полном отсутствии документации
Так что здесь голову не заморачиваем

Строка - вполне нормальный термин, это строка таблицы 
Поле - пересечение строки и атрибута 
Т.е. поле это конкретная клетка таблицы
К примеру, name = Надежда - это поле 

Полем часто могут называть сами колонки, но это не совсем верно

На заметку: употребление слова "атрибут" создает ваш умный образ в глазах собедника - используйте это по назначению

************************************************************************
JOIN 

Итак, мы подошли к самой крупной базовой теме - объединение таблиц при помощи оператора JOIN 
Традиционно, JOIN представляет наибольшую сложность для освоения
Однако, его использование позволит эффективно работать с таблицами (и попутно решать задачки, коих на JOIN великое множество)

SELECT атрибут1, атрибут2... FROM таблица_1 JOIN таблица 2 ON условие 

После SELECT указывает атрибуты, которые должны быть в сводной таблице (можно указывать любые атрибуты из тех таблиц, которые мы джойним)
После FROM указываем первую таблицу, после JOIN - вторую таблицу, и затем условие, по которому будет производиться выборка 
Понятней, конечно же, станет на примерах

Чуть ранее мы воспользовались вот такой командой: 
SELECT women.name, venereal_diseases.disease FROM women JOIN venereal_diseases 
ON
women.venereal_disease = venereal_diseases.id;

Сейчас она уже не отработает, поскольку мы выпилили атрибут с заболеваниями, поэтому нужен другой пример

SELECT women.name, husbands.name FROM women JOIN husbands ON husbands.wife = women.id;

  name   |  name  
---------+--------
 Надежда | Володя
 Карина  | Игорек
 Вера    | Аркаша
(3 rows)

Так, хорошо, но можно лучше. Введем псевдонимы для атрибутов (для внесения ясности) и псевдонимы для таблиц (чтобы сократить код и улучшить его читаемость)

SELECT w.name AS wife, h.name AS husband FROM women w JOIN husbands h ON h.wife = w.id;

  wife   | husband 
---------+---------
 Надежда | Володя
 Карина  | Игорек
 Вера    | Аркаша
(3 rows)

Замечательно. Псевдонимы для таблиц - обыденное дело, для псевдонима обычно берется первая буква из названия таблицы

Кстати, оператор AS вовсе не обязателен: 
SELECT w.name wife, h.name husband FROM women AS w JOIN husbands AS h ON h.wife = w.id;

  wife   | husband 
---------+---------
 Надежда | Володя
 Карина  | Игорек
 Вера    | Аркаша
(3 rows)

Но, распространенная практика для строк прописывать AS, для таблиц - нет
Не знаю, заметили ли вы одну деталь, но есть тут нюанс...
JOIN возвращает только те строки, где есть полное соответствие
То есть, в сводной таблице нет женщин, у которых нет мужей 
Этот вариант джоина называется INNER 
Собственно, параметр INNER просто можно не прописывать, что мы и делали

SELECT w.name wife, h.name husband FROM women AS w INNER JOIN husbands AS h ON h.wife = w.id;

  wife   | husband 
---------+---------
 Надежда | Володя
 Карина  | Игорек
 Вера    | Аркаша
(3 rows)

INNER можно явно указать, но лучше забить на это дело 
Дело в том, что есть два основных типа объединения таблиц:
1. Внутреннее объединение - INNER JOIN 
2. Внешнее объденинеие  - OUTER JOIN 
Отличине в том, что при внутреннем соединении возвращаются все строки из таблиц, которые соответствуют условию 
При внешнем соединении - возвращаются все строки из одной таблицы и соответствующие условию строки из другой таблицы
Параметр INNER и параметр OUTER можно не прописывать 

На картинке ниже можно посмотреть основные виды соединений наглядно (особенно это понравится знатокам математической логики):
https://i.pinimg.com/originals/bc/0c/8b/bc0c8ba4d12051502a68bade9bba4bc5.png

Соединения таблиц можно делать разными способами, но как правило удобней всего с оператором JOIN (для того он и создан, хе-хе)

Есть три вида OUTER JOIN:
1. LEFT JOIN (все строки из первой, левой таблицы, и подпадающие строки из правой)
2. RIGHT JOIN (все строки из правой таблицы, и подпадающие под условие строки из левой)
3. FULL JOIN (все строки из таблиц)

SELECT w.name AS fiwe, h.name AS husband FROM women w LEFT JOIN husbands h ON h.wife = w.id;

  fiwe   | husband 
---------+---------
 Надежда | Володя
 Карина  | Игорек
 Вера    | Аркаша
 Любовь  | 
 Надежда | 
 Вика    | 
(6 rows)


Вот так работает RIGHT JOIN: 
SELECT m.name AS man, p.disorder FROM men m RIGHT JOIN personality_disorders p ON m.personality_disorder = p.id;

      man       |          disorder           
----------------+-----------------------------
 Генерал Кастер | Антисоциальное расстройство
 Сальвадор Дали | Пограничное расстройство
                | Нарциссическое расстройство
                | Истерическое расстройство
(4 rows)

Как располагать таблицы и, соответственно, выбирать левый или правый джоин - чисто логически, в общем как вам больше нравится
 ...хотя бытует мнение, что RIGHT JOIN более распространен


И теперь поговорим про отличие INNER JOIN от FULL JOIN 

SELECT w.name wife, h.name husband FROM women AS w FULL JOIN husbands AS h ON h.wife = w.id;


  wife   | husband 
---------+---------
 Надежда | Володя
 Карина  | Игорек
 Вера    | Аркаша
 Любовь  | 
 Надежда | 
 Вика    | 
(6 rows)

Как видите, запрос INNER JOIN давал только строки где совпадает условие, а здесь выведено все

Отмтим, что хотя некоторые простые кейсы с объединием таблицы можно выполнить с оператором UNION, между UNION  и JOIN есть различия в целях применения:
1. Нужно склеить таблицы по некому условию - выбираем JOIN
2. Нужно просто накидать данных из разных таблиц - выбираем UNION 
С применением JOIN обычно связана некая логика поиска данных по условию






111. Easy SQL: Counting and Grouping
https://www.codewars.com/kata/594633020a561e329a0000a2/train/sql
Вспомним былое. Используйте COUNT. Обратите внимание на Sample Tests - там указано, какие операторы должны присутствовать



SELECT women.name, venereal_diseases.disease FROM women JOIN venereal_diseases ON venereal_diseases.id = women_venereal_diseases.disease_id WHERE venereal_diseases.woman_id = women.id;



https://sql-academy.org/ru/guide/operator-having

https://ravesli.com/having-sql/?ysclid=m5uuzh1j10656321864