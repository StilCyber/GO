************************************************************************
// Порядок установки

Начинаем с классики

    sudo apt update
    sudo apt upgrade

Инсталлируем postgres

    sudo apt install postgresql

Запускаем postgres (утилита systemctl управляет демонами линукса)

    sudo systemctl start postgresql

    ... и проверяем статус демона (должен быть зеленым)
    sudo systemctl status postgresql

    для рестарта (к примеру, при изменении конфигов) демона нужно пнуть 
    sudo systemctl restart postgresql

************************************************************************
// Заходим в пострес 

В постгресе есть свои отдельные пользователи, после установки доступен суперпользователь "postgres", который обладает неограниченными возможностями (что хочет создает, что хочет удаляет)
Для работы с постгресом из терминала используется отдельная консоль - psql. По сути это отдельный терминал, в котором можно вводить команды для работы с постгресом
Можно войти в аккаунт постгреса без входа в консоль psql, но в этом смысла особо нет. Для этого можно использовать следующую команду: sudo -i -u postgres 
Дело в том, что пользователи постгреса связаны с пользователями линукс. Поэтому, при установке пострес создается не только суперпользователь постгрес, но и одноименный аккаунт в операционной системе. 
И здесь нас ждет подстава - по умолчанию для пользователя postgres не задан пароль, поэтому нормально пользоваться им мы пока не сможет, но об этом чуть позже. 
Если вы все же ввели sudo -i -u postgres и не можете оттуда выйти, введите команду: su myAccount, где myAccount - имя вашего основного аккаунта в линуксе, от которого вы знаете пароль - введите этот пароль и возвращаетесь обратно

Для того, чтобы выбрать пользователя посгрес и сразу открыть psql, нужно ввести следующую команду: sudo -u postgres psql
Здесь мы заходим в аккаунт postgres в операционной системе и через него вызываем терминал psql 
Выйти из консоли psql можно командой \q 

Итак, заходит в psql под пользователем postgres (должны увидеть вот такое: postgres=#)
Создаем базу данных с рандомным именем: CREATE DATABASE test; Здесь CREATE DATABASE - оператор создания базы данных, test - собственно название базы данных. 
Для имен БД есть свои правила, так что если введете что-то не так, вам сообщат. Самое основное - нельзя пользоваться дефисами
Если введете CREATE DATABASE test-1; то получите вот такую хрень 
ERROR:  syntax error at or near "-"
LINE 1: CREATE DATABASE test-1;

Чтобы посмотреть список баз данных всех пользователей можно воспользоваться командой \l (или полный вариант \list, без разницы). Чтобы выйти оттуда жмем q

Чтобы посмотреть всех пользователей постгрес, набираем вот такое вот: \du

Создаем таблицу: CREATE TABLE mytable();
Чтобы посмотреть таблицы, имеющиеся в БД, набираем \dt

Теперь разбираемся с подставой с паролем. Для адекватной работы пользователю постгрес нужно задать пароль, по умолчанию у суперюзера postgres его нет, что, в частности, "затрудняет" подключение к БД из редактора кода. 
Нужна следующая команда: ALTER USER postgres WITH PASSWORD 'postgres';
Здесь для пользователя postgres задается пароль 'postgres'

По причине наличия минтайной связи между пользователями постреса и аккаунтами линукса крайне рекомендуется использовать идентичные имена. 
К примеру, создать аккаунт в линуксе с логином karnozavr666 и аккаунт посгрес с логином karnozavr666 (не забываем про пароль) и заходить сразу через него

//Шпаргалка:
Вход в консоль: sudo -u postgres psql
Выход из консоли: \q
Показать всех пользователей: \du
Показать все базы данных: \l
Зайти в базу данных: \c nameDB
Показать таблицы в базе данных: \dt

************************************************************************
// При работе с postgres помним два важных правила:
1. Операторы пишутся капсом (да, это выглядит как абьюз), можно писать lower case (строчными буквами), но best practics, все дела...
2. В конце инструкций всегда нужно ставить точку с запятой (иначе не заработает) - ; 

 P.S. Оператор - это некий набор символов (слово или несколько слов), на первый вид бессвязный, который говорит постресу что мы вообще от него хотим (SELECT, FROM, WHERE, JOIN и др.). Операторы заранее предустановлены разработчиками постгреса.
      Между операторами есть данные, с которыми мы работаем - это операнды. 

 P.S.S. Инструкция - строка кода, которая делает что-то осмысленное (в идеале).

 Пример: вот так выглядит поиск всех строк в столбце name в таблице users: SELECT name FROM users; (это одна инструкция, где SELECT и FROM - операторы, name и users - операнды, точка с запятой означает конец инструкции)

************************************************************************
Подключение postgres в VS CODE

Ставим расширение PostgreSQL (автор Chris Kolkman, там сейчас порядка миллиона скачиваний)
После этого в левой верхней части редактора появится кружка со слоном
Жмякаем на кружку, и затем на плюсик который появится. 
В верхней части редактора откроется небольшое окошко, в котором будет любезно предложено совершить 7 осмысленных действий по порядку:
1. Указать IP адрес хозяина (хоста). При открытии БД, развернутой локально, нужно прописать localhost - 127.0.0.1
2. Ввести пользователя postgres
3. Ввести пароль для этого пользователя
4. Ввести порт, на котором крутится postgres (если вы не лазили в конфигах, то по умолчанию это будет 5432)
5. Указать Standard Connection
6. Выбрать из предложенного списка БД (если выбора нет, то расширение не может подключиться к постгресу)
7. Придумать любое на ваш выбор имя, которое будет отображаться для помойки, которую вы открываете

Скипнуть окошечко можно на любом шаге на клавишу Esc

************************************************************************
Основные действия при работе с postgres
В целях наглядности здесь и далее мы займемся анализом вечно зеленой темы - отношалок. Создадим БД, которая будет отражать отношения между людьми. 
/////

Создание базы данных 
CREATE DATABASE relationship;
Здесь CREATE DATABASE указывает на создание базы данных, relationship - собственно ее название. Вроде, все очевидно.

Создаем первую таблицу, но перед этим немного поговорим о типах данных. 
В постгрес есть разные типы данных, самые распространенные из них следующие:
VARCHAR(255) - строка длиной в определенное количество символов, число которых указывается в скобках
TEXT - строка большой длины 
INT - целые числа
BOOL- true или false

Почитать подробней о типах данных можно вот здесь: https://neon.tech/postgresql/postgresql-tutorial/postgresql-data-types

Создание таблицы (перед этим не забываем коннектиться к нашей БД)
relationship=# CREATE TABLE women(
relationship(# id SERIAL PRIMARY KEY,
relationship(# name VARCHAR(255),
relationship(# husband BOOL,
relationship(# children BOOL,
relationship(# lovers BOOL
relationship(# );

Все указанное выше - одна инструкция, ее можно прописывать в несколько строк для удобства, главное не ошибиться по пути. 

Для каждой сущности нам нужен уникальный идентификатор, как правило, это отдельный айдишник (по сути это искусственная колонка). Однако, в качестве идентификатора можно использовать другое значение, если мы на 100% уверены что оно будет уникальным.
Если бы женщины в таблице были бы астрологами или представителями какой-либо другой древней профессии, то в качестве идентификатора можно было бы использовать номер заказа. 
Здесь для сущности женщина используется id с указанием SERIAL PRIMARY KEY. Отличение идентификатора от первичного ключа в том, что первичный ключ может быть только один в таблице, тогда как идентификаторов может быть несколько. 
SERIAL - это обычный INTEGER, только с автоинкрементом, т.е. при добавлении каждой новой записи генерируется новое значение, которое больше предыдущего на единицу.
PRIMARY KEY - означает, что добавить значение, которое уже есть в таблице, нельзя. 
Чуть позже мы разберет этот момент подробней.

Проверим, что мы насоздавали (\dt)

         List of relations
 Schema | Name  | Type  |  Owner   
--------+-------+-------+----------
 public | women | table | postgres
(1 row)

Должен получиться вот такой вывод в консоль (да, инфу в консоли можно сверстать чтобы красиво выглядело, спасибо разрабам посгреса)

Чтобы вывести описание таблицы, пишем: \d women

                                    Table "public.women"
  Column  |          Type          | Collation | Nullable |              Default              
----------+------------------------+-----------+----------+-----------------------------------
 id       | integer                |           | not null | nextval('women_id_seq'::regclass)
 name     | character varying(255) |           |          | 
 husband  | boolean                |           |          | 
 children | boolean                |           |          | 
 lovers   | boolean                |           |          | 
Indexes:
    "women_pkey" PRIMARY KEY, btree (id)

Дока по созданию таблиц: https://postgrespro.ru/docs/postgresql/16/tutorial-table

Добавим в таблицу первые данные: INSERT INTO women (id, name, husband, children, lovers) VALUES (DEFAULT, 'Вера', TRUE, TRUE, TRUE);
INSERT INTO указывает на операцию вставки, затем следует название таблицы, в скобках указываются столбцы, затем прописываем VALUES и значения для столбцов. Для айдишника всегда указываем DEFAULT (позже рассмотрим почему)

/////
Базовый поиск 

Чтобы посмотреть, что содержится в таблице, нужно воспользоваться поиском.

SELECT * FROM women;

Оператор SELECT указывает на операцию поиска, FROM - говорит, в какой таблице искать, * - найти все что есть (неоптимально, т.к. при добавлении новых данных результат будет меняться)

 id | name | husband | children | lovers 
----+------+---------+----------+--------
  1 | Вера | t       | t        | t
(1 row)

Оптимальней производить поиск по отдельным колонкам:
SELECT name FROM women; 

Дока по добавлению данных в таблицу: https://postgrespro.ru/docs/postgresql/16/tutorial-populate

Теперь рассмотрим удаление строк

Добавим женщину с поэтическим турецким именем Наташа
INSERT INTO women (id, name, husband, children, lovers) VALUES (DEFAULT, 'Наташа',  true, true, true);

... и выпнем ее из таблицы: 
DELETE FROM women WHERE name = 'Наташа';


ЗАДАНИЕ: добавить в таблицу женщин с именами Надежда и Любовь 

/////
Поиск по условию 

Для поиска с условием используется оператор WHERE в сочетании с логическими операторами AND, OR, NOT и операторами =, >, <, >=, <=

Рассмотрим просто пример: мы хотим найти всех женщин, у которых нет мужа. Вот сама таблица 

 id |  name   | husband | children | lovers 
----+---------+---------+----------+--------
  1 | Вера    | t       | t        | t
  2 | Надежда | t       | f        | t
  3 | Любовь  | f       | f        | t
(3 rows)

SELECT * FROM women WHERE husband = FALSE; 

  id   |  name  | husband | children | lovers 
-------+--------+---------+----------+--------
 3 | Любовь | f       | f        | t
(1 row)


Теперь мы найдем женщин, у которых есть и муж, и любовники 

SELECT * FROM women WHERE husband = TRUE AND lovers = TRUE;

 
 id |  name   | husband | children | lovers 
----+---------+---------+----------+--------
  1 | Вера    | t       | t        | t
  2 | Надежда | t       | f        | t
(2 rows)



Сейчас мы подошли к тому, что можем решать первые задачи
1. https://leetcode.com/problems/recyclable-and-low-fat-products/description/
В ней нужно найти все продукты, в которых low_fats = 'Y' и recyclable = 'Y';
Не забываем в качестве языка выбрать PostgreSQL


//////
Группировка данных при выводе

Вначале добавим еще одну колонку в таблицу
ALTER TABLE women ADD COLUMN age INTEGER;

Схематично описать это можно следующим образом:
Оператор ALTER TABLE => название таблицы => оператор ADD COLUMN => название новой колонки => тип данных 

Отлично, теперь нужно занести новые данные в таблицу

UPDATE women SET age = 22 WHERE name = 'Вера';
Смотритесь внимательно в эту строку и разберите ее сами, добавьте возраст для Надежды 25 лет, возраст Любви - 23 года

Должно получиться вот так

 id |  name   | husband | children | lovers | age 
----+---------+---------+----------+--------+-----
  1 | Вера    | t       | t        | t      |  22
  2 | Надежда | t       | f        | t      |  25
  3 | Любовь  | f       | f        | t      |  23
(3 rows)


Для группировки применяется оператор ORDER BY, который по умолчанию сортирует по возрастанию
SELECT * FROM women ORDER BY age;

 id |  name   | husband | children | lovers | age 
----+---------+---------+----------+--------+-----
  1 | Вера    | t       | t        | t      |  22
  3 | Любовь  | f       | f        | t      |  23
  2 | Надежда | t       | f        | t      |  25
(3 rows)

Для группировки по убыванию используется оператор DESC
SELECT * FROM women ORDER BY age DESC;

 id |  name   | husband | children | lovers | age 
----+---------+---------+----------+--------+-----
  2 | Надежда | t       | f        | t      |  25
  3 | Любовь  | f       | f        | t      |  23
  1 | Вера    | t       | t        | t      |  22
(3 rows)

На самом деле, для группировки по возрастанию тоже есть свой оператор - ASC, но он прошит по умолчанию:
SELECT * FROM women ORDER BY age ASC;

 id |  name   | husband | children | lovers | age 
----+---------+---------+----------+--------+-----
  1 | Вера    | t       | t        | t      |  22
  3 | Любовь  | f       | f        | t      |  23
  2 | Надежда | t       | f        | t      |  25
(3 rows)

При группировке можно задать лимит на количество выводимых записей:
SELECT * FROM women ORDER BY age LIMIT 2;

 id |  name  | husband | children | lovers | age 
----+--------+---------+----------+--------+-----
  1 | Вера   | t       | t        | t      |  22
  3 | Любовь | f       | f        | t      |  23
(2 rows)


При выводе можно пропустить определенное число первых строк:
SELECT * FROM women ORDER BY age OFFSET 1;

 id |  name   | husband | children | lovers | age 
----+---------+---------+----------+--------+-----
  3 | Любовь  | f       | f        | t      |  23
  2 | Надежда | t       | f        | t      |  25
(2 rows)


Теперь зададимся вопросом: что если, мы хотим найти только уникальные строки. 
К примеру, нам нужно составить справочник всех женских имен, которые есть в таблице.
Для наглядности, добавим в таблицу еще одну Надежду: INSERT INTO women (id, name, husband, children, lovers, age) VALUES (DEFAULT, 'Надежда', FALSE, FALSE, FALSE, 18);

Теперь поищем все имена: SELECT name FROM women;
  name   
---------
 Вера
 Надежда
 Любовь
 Надежда
(4 rows)


Ммм... отлично, мы вывели весь столбец name. И как избавиться от дублей? Здесь поможет оператор DISTINCT
SELECT DISTINCT name FROM women;

  name   
---------
 Любовь
 Вера
 Надежда
(3 rows)

И еще один кейс, который встречается достаточно часто - мы хотим изменить название самого столбца. Используется для этого оператор AS
SELECT name AS women_name, age AS women_age FROM women;

 women_name | women_age 
------------+-----------
 Вера       |        22
 Надежда    |        25
 Любовь     |        23
 Надежда    |        18
(4 rows)

Сейчас это конечно выглядит бессмысленно, но потом, когда мы будем формировать новый столбец при выводе нам это очень пригодится (при подсчете разных значений, при объединении нескольких таблиц и др.)

ЗАДАЧИ:
2. https://www.codewars.com/kata/5809508cc47d327c12000084/train/sql
Все просто, здесь нужно вывести все строчки, где человек старше 50 лет и сортировать по убыванию

3. https://leetcode.com/problems/big-countries/description/
Тоже ничего сложного, просто нужно верно составить условие

************************************************************************
// Разница между идентификатором и первичным ключом 

Выведем нашу таблицу: SELECT * FROM women;

 id |  name   | husband | children | lovers | age 
----+---------+---------+----------+--------+-----
  1 | Вера    | t       | t        | t      |  22
  2 | Надежда | t       | f        | t      |  25
  3 | Любовь  | f       | f        | t      |  23
  4 | Надежда | f       | f        | f      |  18
(4 rows)

Как видим, айдишники располагаются в строгом порядке от 1 до 4, при этом когда мы добавляли новые строки всегда в качестве значения id указывали DEFAULT
За такой порядок отвечает тип данных SERIAL. Это обычное число (INTEGER), которое при добавлении значения DEFAULT увеличивает предыдущее значение на единицу. 
При работе с SERIAL мы может прописать отдельное правило для определения последовательности, но нам пока это не важно. 
Плюс к этому на этапе создания таблицы мы может задать первое дефолтное значение для последовательности. 

Теперь удалим любовь из нашей жизни:
DELETE FROM women WHERE name = 'Любовь';

SELECT * FROM women;

 id |  name   | husband | children | lovers | age 
----+---------+---------+----------+--------+-----
  1 | Вера    | t       | t        | t      |  22
  2 | Надежда | t       | f        | t      |  25
  4 | Надежда | f       | f        | f      |  18
(3 rows)

У нас удалилась запись с id = 3

... и теперь мы снова захотели влюбиться. 
INSERT INTO women (id, name, husband, children, lovers, age) VALUES (DEFAULT, 'Любовь', FALSE, FALSE, TRUE, 23);

SELECT * FROM women;

 id |  name   | husband | children | lovers | age 
----+---------+---------+----------+--------+-----
  1 | Вера    | t       | t        | t      |  22
  2 | Надежда | t       | f        | t      |  25
  4 | Надежда | f       | f        | f      |  18
  5 | Любовь  | f       | f        | t      |  23
(4 rows)

И тут мы поняли, что в одну реку нельзя войти дважды. 
При использовании типа данных SERIAL расчет нового значения всегда ведется от предыдущего, т.е. от последнего который есть, и в данном случае это 4

Итак, с SERIAL разобрались. Зачем же нужен PRIMARY KEY?

Свяжемся с новой женщиной и попробуем добавить ей значение id из уже существующих. 

INSERT INTO women (id, name, husband, children, lovers, age) VALUES (5, 'Светка', FALSE, TRUE, TRUE, 34);

Получим вот такую ошибку: 
ERROR:  duplicate key value violates unique constraint "women_pkey"
DETAIL:  Key (id)=(5) already exists.

PRIMARY KEY отвечает за то, чтобы в столбце таблицы не было дублирующий значений.
Эх, не видать нам светки как своих ушей. Такая женщина пропадает...


************************************************************************
// Агрегатные функции 

 На практике часто возникают ситуации, когда нужно совершить операцию сразу над несколькими строками, к примеру определить средний возраст женщин
 Тут на помощь спешат агрегатные функции (видимо, их название происходит от слова агрегатор, хе-хе)
 Агрегатная функция совершает действия сразу над несколькими строками и выплевывает результат 

 В постгресе есть 11 агрегатных функций:

 AVG - находит среднее значение

 SUM - находит сумму значений

 MIN - находит минимальное значение

 MAX - находит максимальное значение

 COUNT(*) - находит количество строк в запросе (вместо звездочки подставляем название колонки)

 COUNT(expression) - вместо слова expression подставляете свое значение, и выплевывается результат, где для выражения нет значения Nullable

 BIT_AND - операция логического И 

 BIT_OR - операция логического ИЛИ 

 BOOL_AND - логическое умножение для типа BOOL 

 BOOL_OR - логическое сложение для типа BOOL

 STRING_AGG(expression, delimiter): соединяет с помощью delimiter все текстовые значения из expression в одну строку

 Сейчас нас интересуют первые пять агрегатных функций, остальные пока просто даны для справочник

 ВАЖНО: если нет строк для расчета, то все функции, за исключением COUNT(*), возвращают NULL
 Также нужно отметить, что агрегатные функции используются до оператора WHERE, что вполне логично, т.к. условие выполняется после того, как мы поработали со строками
 Исключение - подзапросы, которые могут быть внутри WHERE (с подзапросами разберемся чуть позже, пока просто узнает, что такое явление существует)

 Обращаем внимание, что функции работают только с определенными типами данных, какими именно - можете погуглить

 Почитать подробней можно здесь: https://postgrespro.ru/docs/postgresql/16/tutorial-agg

 Теперь немного практики
 SELECT COUNT(name) FROM women WHERE name = 'Надежда';

 count 
-------
     2
(1 row)

Обратите внимание на сам запрос - функции COUNT нужно скормить название конкретной колонки, и затем поставить условие
Так, вот так запрос будет ошибочным и не вернет нужной информации: SELECT COUNT('Надежда') FROM women;

Название колонки при выводе - count, что не всегда информативно. Воспользуемся оператором AS
SELECT COUNT(name) AS quantity_women FROM women WHERE name = 'Надежда';

 quantity_women 
----------------
              2
(1 row)

ЗАДАНИЕ: потренируйтесь с функциями AVG, MIN, MAX, SUM на колонке age

************************************************************************
// Продолжаем рассматривать группировку

На текущий момент мы умеет создавать таблицы и производить несложные операции поиска, в т.ч. с использованием агрегатных функций
Однако, этого недостаточно для запросов, когда нужно не просто что-то найти и вычислить, но и фильтрануть результат 
Для фильтрации результата используется оператор HAVING, который часто используется с функцией COUNT(*)


           Оператор HAVING 	                                   Оператор WHERE
Проверяет условие для группы строк 	             Проверяет условие для каждой строки отдельно
Используется с агрегатными функциями 	           Нельзя использовать с агрегатными функциями
Выполняется после оператора GROUP BY	           Выполняется перед оператором GROUP BY

ЗАДАЧИ:

4. Classes More Than 5 Students
https://leetcode.com/problems/classes-more-than-5-students/description/

Базовый пример фильтрации - найдем все строки с классами, сгруппируем их и фильтранем с использованием COUNT

5. Duplicate Emails
https://leetcode.com/problems/duplicate-emails/description/

Для решения задачи нужно найти все строки email, сгруппировать их и отфильтровать с использованием HAVING и COUNT (именно в таком порядке)

6. Find all active students
https://www.codewars.com/kata/5809b9ef88b750ab180001ec/train/sql

Нужно составить простой запрос с WHERE, обращаем внимание, что в колонке IsActive хранится не сам тип boolean, а 1 или 0 

7. SQL Basics: Simple MIN / MAX
https://www.codewars.com/kata/581113dce10b531b1d0000bd/train/sql

Простая задача на агрегатные функции и оператор AS 

8. SQL Basics: Simple DISTINCT
https://www.codewars.com/kata/58111670e10b53be31000108/train/sql

Просто нужно вывести все уникальные возраста, обратите внимание, что менять название столбца не нужно - в описании указано age (distinct), но нужно просто age

9. Adults only (SQL for Beginners #1)
https://www.codewars.com/kata/590a95eede09f87472000213/train/sql

Несложная задача на оператор WHERE (выполняет только если вам больше 18)

10. SQL Basics: Simple SUM
https://www.codewars.com/kata/58110da0009b4f7ef80000ad/train/sql

Используем агрегатную функцию SUM и оператор AS

11. On the Canadian Border (SQL for Beginners #2)
https://www.codewars.com/kata/590ba881fe13cfdcc20001b4/train/sql

Нужно верно составить условие с использованием логических операторов

12. SQL Grasshopper: Select Columns
https://www.codewars.com/kata/582365c18917435ab3000020/train/sql

Просто нужно вывести несколько колонок, всего-то лишь (хз почему кузнечик)

13. Collect Tuition (SQL for Beginners #4)
https://www.codewars.com/kata/5910b0d378cc2ba91400000b/train/sql

Выводим все колонки таблицы (в том числе колонку с данными об оплате), где строки соответствую условию


************************************************************************
// Функции 

Ранее мы пощупали агрегатные функции, которые оперируют группой значений. 
А если нам нужно просто совершить действие над одним значением?
Для этого существуют разные готовые решения
Примеры:

ROUND - округление числа
FLOOR - округление числа вниз
CEILING - округление числа вверх
TRUNCATE - позволяет отбросить определенное число знаков после запятой

ЗАДАЧИ:
14. Easy SQL: Rounding Decimals
https://www.codewars.com/kata/594a6133704e4daf5d00003d/train/sql

Нюанс в том, что когда мы применили функцию к значению, нужно отдельно обозначить имя колонки (оператор AS), поскольку функция здесь выплевывает не строку, а значение

15. Easy SQL: LowerCase
https://www.codewars.com/kata/594800ba6fb152624300006d/train/sql

Самостоятельно узнайте в гугле, какую функцию нужно применить

16. SQL Basics: Mod
https://www.codewars.com/kata/594a9592704e4d21bc000131/train/sql

В этой задаче речь идет о функции MOD(), которая возвращает остаток от деления

17. Register for the Party (SQL for Beginners #3)
https://www.codewars.com/kata/590cc86f7557c0494000007e/train/sql

Обычная операция вставки, обратите внимание на код - в верхней строке уже стоит INSERT, нижнюю строку с поиском оставляем

18. Easy SQL: Convert to Hexadecimal
https://www.codewars.com/kata/594a50bafd3b7031c1000013/train/sql

Нужно перевести числа из десятичной системы счисления в шестнадцатеричную 

19. Easy SQL: Square Root and Log
https://www.codewars.com/kata/594a691720ac16a544000075/train/sql

Если вдруг не знаете что такое логарифм (кусь) - скипайте

20. Easy SQL - Ordering
https://www.codewars.com/kata/593ed37c93350098d600001d/train/sql

Задача с группировкой по убыванию

21. Find Followers Count
https://leetcode.com/problems/find-followers-count/description/

Вот мы и подошли к интересной задачке. Для ее решения нужно представлять структуру запроса.
В данном случае - получить строки (с использованием агрегатной функции), сформировать группы и отсортировать их 


https://sql-academy.org/ru/guide/operator-having

https://ravesli.com/having-sql/?ysclid=m5uuzh1j10656321864