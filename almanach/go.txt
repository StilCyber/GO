Базовый практический курс по языку GO (попутно семейное право узнаете)

************************************************************************
Установка языка

Актуальный порядок установки вот здесь (на этой же странице зеленая кнопка Download)
https://go.dev/doc/install

Windows 
Виндузятники просто скачивают пакет, затем два клика левой клавишей, и следуем инструкциям установщика

Проверяем версию go в командной строке: 
go version

Linux
Для линуксоидов все хитрее 

Открываем терминал в папке, куда был скачен пакет, и говорим что нужно распаковать и поставить:
sudo tar -C /usr/local -xzf go1.23.5.linux-amd64.tar.gz

Добавляем путь к go в переменные окружения:
export PATH=$PATH:/usr/local/go/bin

Проверяем все ли в порядке:
go version

Теминал должен выплюнуть примерно такую строку:
go version go1.23.5 linux/amd64


Mac
Если вы фанат оси, то в объяснениях вы вряд ли нуждаетесь

************************************************************************
VS CODE и первая программа 

В качестве редактора кода можно разные варианты использовать, но goland платный, а ломаные версии не факт что стабильно отработают
Поэтому устанавливаем VS CODE и расширение в нем для GO авторства Go Team at Google. Да-да, гугл не только сляпал язык, но еще и любезно предоставил штуковины, которая подружит его с VS CODE

Теперь создаем папку с именем, к примеру, projectGo, и внутри нее файл main.go 
Помещаем туда следующий код: 

////////////

package main 

import "fmt"

func main() {
    fmt.Println("I am GO! Ha-ha")
}

////////////

Косые черточки сверху и снизу просто отделяют код от другого текста, не копируем их (^_^)

Сейчас IDE будет ругаться на слово main, т.к. работа с пакетами возможна только внутри модуля
Чтобы создать модуль, нужно открыть терминал в папке проекта, и ввести следующую команду:
go mod init projectGo 

Здесь projectGo - название вашей папки, в которую вы поместили main.go 
После этого должен сгенерироваться файл go.mod 

Теперь можно запустить код:
go run main.go

В консоли появится строчка "I am GO! Ha-ha"

Теперь разбираем, что происходит 

Проект на GO может состоять из большого числа папок и файлов, и чтобы все работало корректно есть одна точка входа - это функция main 
Функция main может быть только одна на весь проект, ее не нужно отдельно вызывать

go run main.go - разберем подробней
go - утилита go
run - команда которая есть в этой утилите, говорит что нужно запустить файлов
main.go - указание на конкретный исполняемый файл 

package main - внешне код внутри проекта выглядит как папки с файлами, но логическая структура кода (как организованы связи) складывается из модулей и пакетов (об этом еще поговорим)
   Как правило, проект является отдельным модулем (в следующих разделах мы создадим такой модуль), состоящим из пакетов.
   package - означает пакет, main - название пакета. Наличие пакета main обязательно, это главный пакет. 

import "fmt" - слово import означает, что мы подключаем другой пакет, в данном случае - пакет fmt, который предоставляем функционал по выводу информации

func - слово, которое означает, что мы имеем дело с функцией 
func main() {} - сама функция с названием main, в круглых скобках функции () указываются параметры - это данные, которые мы ей скармливаем, в фигурных скобках {} - тело функции, т.е. ее код
   В функции main параметры не передаются

fmt.Println("I am the GO! Ha-ha") - мы обращаемся к пакету fmt, берем из него функцию Prinln, которая выводит что-то в консоль, и засовываем туда строку "I am the GO! Ha-ha"

Как можно догадаться, пакет fmt где-то существует, раз мы можем его использовать - это один из встроенных пакетов, 
   когда инсталлировали go, создалась отдельная папка с его файлами, где есть в том числе и разные готовые пакеты

Теперь про одно из базовых понятий - переменные
Если спросить у гугла что это такое, то он скажем примерно следующее: "область памяти, где хранятся данные"
Когда программа работает, в этой движухе задействованы разные данные (к примеру, строка "I am GO! Ha-ha" из предыдущего примера)
Данные помещаются в оперативную память компьютера
Достаточно распространенная аналогия - переменная это как коробка с вашим барахлом 
Для того чтобы работать с данными для начала нужно создать коробку и заполнить ее всякой всячиной 

Переменные в go можно создавать разными способами, начнем с основного с использованием ключевого слова var 

Допустим, мы хотим хранить имя жены:

var wife string 
wife = "Некая тян"

Здесь произошло следующее:
1. Объявление переменной - создание той самой коробочки (ключевое слово var, затем имя переменной wife, затем тип переменной - string, т.е. строка)
2. Инициализация переменной - первоначальное заполнение барахлом, в данном случае обозначением жены

И здесь немного казуистики 
Объявить переменную можно одновременно с ее инициализацией:
var wife = "Некая тян"

Однако, если мы просто объявим переменную, она все равно под капотом заполнится дефолтным значением в зависимости от типа данных - для string это будет пустая строка
Но это не инициализация, не путайте. Это другое...

Задается значение переменной с использованием оператора присваивания (=). Когда мы задаем значение в первый раз, это инициализация - дальше ну... вы понимаете 

Обратите внимание на поток выполнения кода в примере ниже. Базово, он идет последовательно сверху вниз

//////////////

func main() {
	var wife = "Некая тян"
	fmt.Println(wife)

	wife = "Кисуля"
	fmt.Println(wife)
}

//////////////

В результате выполнения мы получим следующее:
Некая тян
Кисуля

После того, как мы изменили значение переменной, в консоль во второй раз вывелся уже новый результат

Имена переменных менять нельзя, значения можно
Нужно отдельно выделить такой вид переменных, как константы, их значение устанавливается только один раз и попытка его изменить вызовет ошибку
Константы инициализируются сразу же при объявлении (логично же ведь)
Представим, что другой жены не будет:

////////////

func main() {
	const wife = "Кисуля"
	fmt.Println(wife)
}

////////////

Теперь поговорим о таком явлении, как "затенение" переменных 
Переменные имеют области видимости - если говорить прям совсем просто, то переменные, объявленные внутри функции, существуют только в ней самой. Позже мы к этому еще вернемся (наверное...)

Некоторые замечания:
- go признает только двойные кавычки
- если объявили переменную, нужно обязательно где-то ее использовать, иначе код тупо не запустится

ЗАДАНИЕ:
1.1 У супругов в браке есть ряд прав и обязанностей, но они, в кавычках, равны. 
    Прочитайте ч.1 ст. 31 Семейного кодекса РФ и выведите ее в консоль 

    Закон не ограничивает супругов в выборе своих занятий и места жительства
    То есть, никто не может запретить жене не ночевать дома и ходить по клубам, 
       в то время как ее муж может шпилиться в танки 

    Занесите текст ч.1. ст. 31 в переменную и скормите эту переменную функции Println

************************************************************************
Работа со строками

В GO есть разные типы данных, которые условно можно разделить на две группы:
1. Примитивные типы
2. Составные типы (состоят из примитивов)

Примитивные значения - это строки, числа, булевы значения, также сюда можно приписать отсутствие значения (nil)
Основные примитивы следующие:
1. string - строковый тип: последовательность символов, заключенная в двойные кавычки 
2. целочисленные типы:
   - int 
   - uint 
3. вещественные числа:
   - float32
   - float64
3. Булевы значения - true и false (тип boolean)
4. Отсутствие значения - nil 

Отметим, что целочисленных типов достаточно немало
- int8:  от -128 до 127
- int16: от -32768 до 32767
- int32: целое число от -2147483648 до 2147483647
- int64: целое число от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807
Здесь цифра справа от int означает количество бит
При определении типа данных, который будет использоваться, желательно брать тот, что меньше 

Есть и типы данных для неотрицательных чисел:
- uint8: от 0 до 255
- uint8: от от 0 до 65535
- uint8: от 0 до 4294967295
- uint8: от 0 до 18 446 744 073 709 551 615

Некоторые примеры:
- если нужно указать возраста ваших подруг и жены, выбираем uint8
- если нужно определить, есть ли вообще у вас жена (надеемся, что нет), выбираем булево значение


Ранее было написано про int и uint, и здесь противоречия нет
Если мы не указываем количество бит, то по умолчанию это будет, "в зависимости от обстоятельст", 32 или 64 бита

Есть еще такие интересные типы, как byte (синоним uint8) и rune (синоним int32), с чем мы еще неизбежно столкнемся 

Составные типы пока оставим в стороне, успеем еще с ними намучиться
Пока просто скажем, что это:
- массивы
- слайсы
- структуры
- мапы

ЗАДАНИЕ
1.2 Выясните, что такое "источник права", найдите источники семейного права,
    выберите штук пять основных (с конкретикой - не просто федеральный закон, а конкретный закон),
    занесите каждый из них в отдельную переменную и выведите в консоль с заголовком "Источники семейного права"

1.3 Опишите портрет среднестатистической женщины - для каждого "свойства" заведите отдельную переменную
    при этом используйте как можно больше разных типов данных. Можете перечислить штук десять свойств -
    муж, любовники, дети, заболевания, домашние питомцы, уровень агрессии, образование, льготы пособие и прочее 

Не забудьте глянуть в альманахе раздел с переменными - там указаны основные способы их создания.

************************************************************************
Условное ветвление 

Представьте, что надо принять решение по обстоятельствам
Вот, например, на улице идет дождь, и вам было бы неплохо захватить с собой зонтик
Но, начался регулярный утренний ивент - истерика жены. 
Если вы возьмете зонт, то не промокнете, но попадете под горячую руку
Если быстро выскочите из дома, то превратитесь в мокрую псину 

///////////

package main 

import "fmt"

func main() {
	var decision bool

	fmt.Println("Ваш выбор:")
	fmt.Scan(&decision)

	if decision {
		fmt.Println("Вы не промокнете на улице, но ходе поисков зонта вас огрели сковородой - вы получаете -20xp.\nВ добавок к этому, череда оскроблений снизила вашу силу воли на 20 единиц в течение 24 часов")
	} else {
		fmt.Println("Вам удалось избежать побоев, но вы сильно промокли и к вечеру простудились.\nТеперь придется взять больничный и пару-тройку дней терпеть новые издевательства.\nВы получаете -60xp и -25% к психической воспротивляемости пока не поправитесь")
	}
}

///////////

Итак, что нового
Помимо уже привычной нам функции fmt.Println() добавилась функция fmt.Scan()
fmt.Scan() отвечает за ввод данных - то есть, программа предлагает пользователю немного потыкать в консоли
Амперсанд (&) - это указатель, он говорит, что нужно записать введенные данные вот в такую переменную 
Про указатели вообще будет отдельный разговор, пока тупо запомним что так нужно 

Само ветвление исчерпывающим образом выглядит так:

if условие {
   некий сомнительный код
} else if другое условие {
   еще более подозрительно
} else {
   если везде отшили
}

Блок кода сразу после if выполняется только тогда, когда условие истинно 
В нашей ситуации с зонтиком мы напрямую передаем true или false, что облегчает работу
Сама конструкция ветвления может быть сколь угодно простой или сложной (хотя сложное на не надо)
К примеру, часто встречается только один if 

if условие {
   некий сомнительный код
}

Может быть несколько конструкций else if, но else в отдельности - либо есть одно, либо нет

У конструкции if else есть слабое место - если много условий и вариантов, она может выглядить очень громоздко 
Нерационально выглядят следующие случаи:
1. Вложенное ветвление:

if условие {
   некий сомнительный код
} else if другое условие {
   еще более подозрительно
   
   if новое условие {
      сомнительный код 2
   } else {
      скрытый в глубине новый вариант событий
   }

} else {
   если везде отшили
}

2. Слишком много else:

if условие {
   некий сомнительный код
} else if другое условие {
   еще более подозрительно
} else if еще условие {
   еще более подозрительно
} else if новое условие {
   еще более подозрительно
} else {
   если везде отшили
}

Хотя на практике и встречаются случаи, когда вложенного ветвления или черезы else не избежать, но как правило такие ситуации избегаются

Одни из способов работы с ветвлением, когда есть много разных вариантов выбора, является оператор switch




ЗАДАНИЕ:
1.4 По статистике, женатые мужчины живут меньше своих холостых собратьев примерно на 25% 
    Напишите программу, которая принимает на вход возраст мужчины и сведения о том, женат он или нет 
    Также в коде должна быть константа со средним возрастом жизни мужчины - это 59 лет 
    Программа должна делать следующее:
    - проверить, состоит ли мужчина в "законных" отношениях
    - если ответ положительный, то подсчитать оставшийся срок жизни (59 лет - возраст мужчины, от полученной суммы отнимем 25%) и вывести в консоль
    - при отрицательном ответе вывывести в консоль "Пусть поживет еще"
    - если возраст мужчины превышает 59 лет и он женат - вывести "Не ищи надежды там где ее нет"
1.5 Представим, что мы по приколу решили поработать сотрудником загса на приемке документов 
    Но, при этом мы ленивый интроверт, и решили написать программу, которая будет сама определять, может ли пара пожениться 
    Напишите программу, которая на основе входных данных определяет:
    - соблюдены ли условия вступления в брак (ст. 12 СК РФ)
    - имеются ли препятствия для заключения брака (ст. 14 СК РФ)
    В итоге программа должна выплюнуть решение - да или нет, и если нет, то почему
      