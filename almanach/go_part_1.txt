Базовый практический курс по языку GO (попутно семейное право узнаете)

************************************************************************
Установка языка

Актуальный порядок установки вот здесь (на этой же странице зеленая кнопка Download)
https://go.dev/doc/install

Windows 
Виндузятники просто скачивают пакет, затем два клика левой клавишей, и следуем инструкциям установщика

Проверяем версию go в командной строке: 
go version

Linux
Для линуксоидов все хитрее 

Открываем терминал в папке, куда был скачен пакет, и говорим что нужно распаковать и поставить:
sudo tar -C /usr/local -xzf go1.23.5.linux-amd64.tar.gz

Добавляем путь к go в переменные окружения:
export PATH=$PATH:/usr/local/go/bin

Проверяем все ли в порядке:
go version

Теминал должен выплюнуть примерно такую строку:
go version go1.23.5 linux/amd64


Mac
Если вы фанат оси, то в объяснениях вы вряд ли нуждаетесь

************************************************************************
VS CODE и первая программа 

В качестве редактора кода можно разные варианты использовать, но goland платный, а ломаные версии не факт что стабильно отработают
Поэтому устанавливаем VS CODE и расширение в нем для GO авторства Go Team at Google. Да-да, гугл не только сляпал язык, но еще и любезно предоставил штуковины, которая подружит его с VS CODE

Теперь создаем папку с именем, к примеру, projectGo, и внутри нее файл main.go 
Помещаем туда следующий код: 

////////////

package main 

import "fmt"

func main() {
    fmt.Println("I am GO! Ha-ha")
}

////////////

Косые черточки сверху и снизу просто отделяют код от другого текста, не копируем их (^_^)

Сейчас IDE будет ругаться на слово main, т.к. работа с пакетами возможна только внутри модуля
Чтобы создать модуль, нужно открыть терминал в папке проекта, и ввести следующую команду:
go mod init projectGo 

Здесь projectGo - название вашей папки, в которую вы поместили main.go 
После этого должен сгенерироваться файл go.mod 

Теперь можно запустить код:
go run main.go

В консоли появится строчка "I am GO! Ha-ha"

Теперь разбираем, что происходит 

Проект на GO может состоять из большого числа папок и файлов, и чтобы все работало корректно есть одна точка входа - это функция main 
Функция main может быть только одна на весь проект, ее не нужно отдельно вызывать

go run main.go - разберем подробней
go - утилита go
run - команда которая есть в этой утилите, говорит что нужно запустить файлов
main.go - указание на конкретный исполняемый файл 

package main - внешне код внутри проекта выглядит как папки с файлами, но логическая структура кода (как организованы связи) складывается из модулей и пакетов (об этом еще поговорим)
   Как правило, проект является отдельным модулем (в следующих разделах мы создадим такой модуль), состоящим из пакетов.
   package - означает пакет, main - название пакета. Наличие пакета main обязательно, это главный пакет. 

import "fmt" - слово import означает, что мы подключаем другой пакет, в данном случае - пакет fmt, который предоставляем функционал по выводу информации

func - слово, которое означает, что мы имеем дело с функцией 
func main() {} - сама функция с названием main, в круглых скобках функции () указываются параметры - это данные, которые мы ей скармливаем, в фигурных скобках {} - тело функции, т.е. ее код
   В функции main параметры не передаются

fmt.Println("I am the GO! Ha-ha") - мы обращаемся к пакету fmt, берем из него функцию Prinln, которая выводит что-то в консоль, и засовываем туда строку "I am the GO! Ha-ha"

Как можно догадаться, пакет fmt где-то существует, раз мы можем его использовать - это один из встроенных пакетов, 
   когда инсталлировали go, создалась отдельная папка с его файлами, где есть в том числе и разные готовые пакеты

Теперь про одно из базовых понятий - переменные
Если спросить у гугла что это такое, то он скажем примерно следующее: "область памяти, где хранятся данные"
Когда программа работает, в этой движухе задействованы разные данные (к примеру, строка "I am GO! Ha-ha" из предыдущего примера)
Данные помещаются в оперативную память компьютера
Достаточно распространенная аналогия - переменная это как коробка с вашим барахлом 
Для того чтобы работать с данными для начала нужно создать коробку и заполнить ее всякой всячиной 

Переменные в go можно создавать разными способами, начнем с основного с использованием ключевого слова var 

Допустим, мы хотим хранить имя жены:

var wife string 
wife = "Некая тян"

Здесь произошло следующее:
1. Объявление переменной - создание той самой коробочки (ключевое слово var, затем имя переменной wife, затем тип переменной - string, т.е. строка)
2. Инициализация переменной - первоначальное заполнение барахлом, в данном случае обозначением жены

И здесь немного казуистики 
Объявить переменную можно одновременно с ее инициализацией:
var wife = "Некая тян"

Однако, если мы просто объявим переменную, она все равно под капотом заполнится дефолтным значением в зависимости от типа данных - для string это будет пустая строка
Но это не инициализация, не путайте. Это другое...

Задается значение переменной с использованием оператора присваивания (=). Когда мы задаем значение в первый раз, это инициализация - дальше ну... вы понимаете 

Обратите внимание на поток выполнения кода в примере ниже. Базово, он идет последовательно сверху вниз

//////////////

func main() {
	var wife = "Некая тян"
	fmt.Println(wife)

	wife = "Кисуля"
	fmt.Println(wife)
}

//////////////

В результате выполнения мы получим следующее:
Некая тян
Кисуля

После того, как мы изменили значение переменной, в консоль во второй раз вывелся уже новый результат

Имена переменных менять нельзя, значения можно
Нужно отдельно выделить такой вид переменных, как константы, их значение устанавливается только один раз и попытка его изменить вызовет ошибку
Константы инициализируются сразу же при объявлении (логично же ведь)
Представим, что другой жены не будет:

////////////

func main() {
	const wife = "Кисуля"
	fmt.Println(wife)
}

////////////

Теперь поговорим о таком явлении, как "затенение" переменных 
Переменные имеют области видимости - если говорить прям совсем просто, то переменные, объявленные внутри функции, существуют только в ней самой. Позже мы к этому еще вернемся (наверное...)

Некоторые замечания:
- go признает только двойные кавычки
- если объявили переменную, нужно обязательно где-то ее использовать, иначе код тупо не запустится

ЗАДАНИЕ:
1.1 У супругов в браке есть ряд прав и обязанностей, но они, в кавычках, равны. 
    Прочитайте ч.1 ст. 31 Семейного кодекса РФ и выведите ее в консоль 

    Закон не ограничивает супругов в выборе своих занятий и места жительства
    То есть, никто не может запретить жене не ночевать дома и ходить по клубам, 
       в то время как ее муж может шпилиться в танки 

    Занесите текст ч.1. ст. 31 в переменную и скормите эту переменную функции Println

************************************************************************
Работа со строками

В GO есть разные типы данных, которые условно можно разделить на две группы:
1. Примитивные типы
2. Составные типы (состоят из примитивов)

Примитивные значения - это строки, числа, булевы значения, также сюда можно приписать отсутствие значения (nil)
Основные примитивы следующие:
1. string - строковый тип: последовательность символов, заключенная в двойные кавычки 
2. целочисленные типы:
   - int 
   - uint 
3. вещественные числа:
   - float32
   - float64
3. Булевы значения - true и false (тип boolean)
4. Отсутствие значения - nil 

Отметим, что целочисленных типов достаточно немало
- int8:  от -128 до 127
- int16: от -32768 до 32767
- int32: целое число от -2147483648 до 2147483647
- int64: целое число от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807
Здесь цифра справа от int означает количество бит
При определении типа данных, который будет использоваться, желательно брать тот, что меньше 

Есть и типы данных для неотрицательных чисел:
- uint8: от 0 до 255
- uint8: от от 0 до 65535
- uint8: от 0 до 4294967295
- uint8: от 0 до 18 446 744 073 709 551 615

Некоторые примеры:
- если нужно указать возраста ваших подруг и жены, выбираем uint8
- если нужно определить, есть ли вообще у вас жена (надеемся, что нет), выбираем булево значение


Ранее было написано про int и uint, и здесь противоречия нет
Если мы не указываем количество бит, то по умолчанию это будет, "в зависимости от обстоятельст", 32 или 64 бита

Есть еще такие интересные типы, как byte (синоним uint8) и rune (синоним int32), с чем мы еще неизбежно столкнемся 

Составные типы пока оставим в стороне, успеем еще с ними намучиться
Пока просто скажем, что это:
- массивы
- слайсы
- структуры
- мапы

ЗАДАНИЕ
1.2 Выясните, что такое "источник права", найдите источники семейного права,
    выберите штук пять основных (с конкретикой - не просто федеральный закон, а конкретный закон),
    занесите каждый из них в отдельную переменную и выведите в консоль с заголовком "Источники семейного права"

1.3 Опишите портрет среднестатистической женщины - для каждого "свойства" заведите отдельную переменную
    при этом используйте как можно больше разных типов данных. Можете перечислить штук десять свойств -
    муж, любовники, дети, заболевания, домашние питомцы, уровень агрессии, образование, льготы пособие и прочее 

Не забудьте глянуть в альманахе раздел с переменными - там указаны основные способы их создания.

************************************************************************
Условное ветвление 

Представьте, что надо принять решение по обстоятельствам
Вот, например, на улице идет дождь, и вам было бы неплохо захватить с собой зонтик
Но, начался регулярный утренний ивент - истерика жены. 
Если вы возьмете зонт, то не промокнете, но попадете под горячую руку
Если быстро выскочите из дома, то превратитесь в мокрую псину 

///////////

package main 

import "fmt"

func main() {
	var decision bool

	fmt.Println("Ваш выбор:")
	fmt.Scan(&decision)

	if decision {
		fmt.Println("Вы не промокнете на улице, но ходе поисков зонта вас огрели сковородой - вы получаете -20xp.\nВ добавок к этому, череда оскроблений снизила вашу силу воли на 20 единиц в течение 24 часов")
	} else {
		fmt.Println("Вам удалось избежать побоев, но вы сильно промокли и к вечеру простудились.\nТеперь придется взять больничный и пару-тройку дней терпеть новые издевательства.\nВы получаете -60xp и -25% к психической воспротивляемости пока не поправитесь")
	}
}

///////////

Итак, что нового
Помимо уже привычной нам функции fmt.Println() добавилась функция fmt.Scan()
fmt.Scan() отвечает за ввод данных - то есть, программа предлагает пользователю немного потыкать в консоли
Амперсанд (&) - это указатель, он говорит, что нужно записать введенные данные вот в такую переменную 
Про указатели вообще будет отдельный разговор, пока тупо запомним что так нужно 
\n - перевод строки

Само ветвление исчерпывающим образом выглядит так:

if условие {
   некий сомнительный код
} else if другое условие {
   еще более подозрительно
} else {
   если везде отшили
}

Блок кода сразу после if выполняется только тогда, когда условие истинно 
В нашей ситуации с зонтиком мы напрямую передаем true или false, что облегчает работу
Сама конструкция ветвления может быть сколь угодно простой или сложной (хотя сложное нам не надо, нахер оно надо)
К примеру, часто встречается только один if 

if условие {
   некий сомнительный код
}

Может быть несколько конструкций else if, но else в отдельности - либо есть одно, либо нет

У конструкции if else есть слабое место - если много условий и вариантов, она может выглядить очень громоздко 
Нерационально выглядят следующие случаи:
1. Вложенное ветвление:

if условие {
   некий сомнительный код
} else if другое условие {
   еще более подозрительно
   
   if новое условие {
      сомнительный код 2
   } else {
      скрытый в глубине новый вариант событий
   }

} else {
   если везде отшили
}

2. Слишком много else:

if условие {
   некий сомнительный код
} else if другое условие {
   еще более подозрительно
} else if еще условие {
   еще более подозрительно
} else if новое условие {
   еще более подозрительно
} else {
   если везде отшили
}

Хотя на практике и встречаются случаи, когда вложенного ветвления или черезы else не избежать, но как правило такие ситуации избегаются

Одни из способов работы с ветвлением, когда есть много разных вариантов выбора, является оператор switch

///////

package main

import "fmt"

const messageTrue = "Вы не промокнете на улице, но ходе поисков зонта вас огрели сковородой - вы получаете -20xp.\nВ добавок к этому, череда оскроблений снизила вашу силу воли на 20 единиц в течение 24 часов"
const messageFalse = "Вам удалось избежать побоев, но вы сильно промокли и к вечеру простудились.\nТеперь придется взять больничный и пару-тройку дней терпеть новые издевательства.\nВы получаете -60xp и -25% к психической воспротивляемости пока не поправитесь"

func main() {
	var decision bool

	fmt.Println("Ваш выбор:")
	fmt.Scan(&decision)

	switch decision {
	case true:
		fmt.Println(messageTrue)

	case false:
		fmt.Println(messageFalse)
	}
}

//////////

После оператора switch указываем переменную, значения которой будут применяться в кейсах 
Если decision = true, то fmt.Println() отработает с переменной messageTrue, если false - messageFalse
Здесь мы немного декомпозировали код, когда вывели текст сообщений в отдельные константы
Как только отрабатывает один из кейсов, дальше поток не идет, и мы выходим из switch 
В отличие от многих других языков программирования, в go в switch case не требуется дефолтный кейс(default), который отрабатывает в любом случае, хотя мы может его указать,
и нет нужды ставить break в конце каждого кейса, что означало бы выход из констукции switch case 

Перед решением заданий посмотрите в альманахе темы АРИФМЕТИКА и УСЛОВИЯ И ЛОГИКА

ЗАДАНИЕ:
1.4 По статистике, женатые мужчины живут меньше своих холостых собратьев примерно на 25% 
    Напишите программу, которая принимает на вход возраст мужчины и сведения о том, женат он или нет 
    Также в коде должна быть константа со средним возрастом жизни мужчины - это 59 лет 
    Программа должна делать следующее:
    - проверить, состоит ли мужчина в "законных" отношениях
    - если ответ положительный, то подсчитать оставшийся срок жизни (59 лет - возраст мужчины, от полученной суммы отнимем 25%) и вывести в консоль
    - при отрицательном ответе вывывести в консоль "Пусть поживет еще"
    - если возраст мужчины превышает 59 лет и он женат - вывести "Не ищи надежды там где ее нет"
1.5 Представим, что мы по приколу решили поработать сотрудником загса на приемке документов 
    Но, при этом мы ленивый интроверт, и решили написать программу, которая будет сама определять, может ли пара пожениться 
    Напишите программу, которая на основе входных данных определяет:
    - соблюдены ли условия вступления в брак (ст. 12 СК РФ)
    - имеются ли препятствия для заключения брака (ст. 14 СК РФ)
    В итоге программа должна выплюнуть решение - да или нет, и если нет, то почему


 ************************************************************************
 Циклы

В go есть только один цикл - это цикл for 
В базовом варианте цикл for представлет собой условие плюс счетчик 

////////////////

func main() {
	children := 0

	for i := 0; i < 3; i++ {
		fmt.Printf("Сейчас детей: %v\n", children)
		fmt.Println("Нужно родить еще")
		children++
	 }
	 
	 if children == 3 {
		fmt.Printf("Сейчас детей: %v\n", children)
		fmt.Println("Льгота получена")
	 } else {
		fmt.Println("Что-то... что-то пошло не так")
	 }
}

////////////////

В этом примере женщина хочет не работать и получать льготы. Разберем подробней
i := 0 - объявление и инициализация переменной-счетчика.
         В приниципе эту переменную можно объявить и в другом месте, но удобней это делать при задании самого цикла
i < 3 - условие для продолжение цикла
i++ - увеличение счетчика на единицу

При каждой итерации счетчик будет увеличиваться на единицу

fmt.Printf("Сейчас детей: %v\n", children) - новая для нас функция, она используется на вывода текста и значений переменных
    модификатор %v - означает значение (value), в данном случае выводится значение переменной children

В других языках предусмотрен еще и цикл while, но в go он реализуется через синтаксис for

Ситуация следующая. Женщина захотела выйти замуж чтобы обнулиться. 
Поскольку этот вопрос для нее принципиально важен,
она хочет, чтобы хотя бы в день свадьбы число ее любовников составляло 0 человек
На вход подается число любовников, и до тех пор пока оно больше нуля, мы его декрементируем
На всякий случай поставим проверку при выводе финальной информации

////////////////

   var lovers uint

	fmt.Println("Введите количество любовников")
	fmt.Scan(&lovers)

	for lovers > 0 {
		fmt.Printf("Текущее число любовников: %v\n", lovers)
		lovers--
	}

	if lovers == 0 {
		fmt.Printf("Текущее число любовников: 0\n")
		fmt.Println("Пора обнуляться")
	} else {
		fmt.Println("Что-то снова пошло не так...")
	}

////////////////

Различия между for и for как while становятся очевидными при более сложных действиях - к примеру, 
     когда нужно будет не декрементировать, а удалять элементы из слайса, но это чуть позже 

У циклов есть две важных фишечки:
1. Оператор continue
2. Оператор breake

Мы может прервать тело цикла в любой удобный момент оператором continue
Также мы может полностью остановить цикл оператором breake

Чтобы показать реальную пользу continue и break, заглянем в будущее
Мариночка рассталась с парнем, и теперь ей нужно поднять свой алений хоровод и оперативно найти замену
Марина - женщина прогрессивная и в случайности не верит, поэтому она обратилась за помощью к местному нумерологу 
Нумеролог на основе анализа ее имени и даты рождения сказал выдал следующие рекомендации:
- в имени мужчины должно быть более пяти букв, иначе личная жизнь с ним не сложится
- сумма индексов букв имени должна составлять счастливое число, которое определяется как день рождения мариночки минус сегодняшнее число (очевидно, что по модулую)
Короче, нам безраличен этот бред, к тому же мариночка не знает что такое модуль числа (не будьте как мариночка), поэтому она просто наугад придумывает числа 
В программе есть константа - 6, переменная num которую вводит пользователь, слайс с именами

Оператор continue прерывает тело цикла, если в имени меньше букв, чем в константе minLetter
Если найдено первое совпадение, то цикл заканчивается
Если мы дошли до последнего имени, но цикл не прервался - значит ничего не найдено


////////////////


func main() {
	const minLetter = 6

	var num int

	fmt.Println("Введите сумму")
	fmt.Scan(&num)

	names := []string{"Тимур", "Вазген", "Виталий", "Бахтияр", "Пахлавон"}

	for index, value := range names {

		if(len(value) < minLetter) {
			continue
		}

		sum := countLetters(len([]rune(value)))

		if sum == num {
			fmt.Printf("Кандидат найден, это %v\n", value)
			break
		}

		if index == len(names) - 1 {
			fmt.Printf("Увы, но звезды не сошлись\n")
		}

	}
}

func countLetters(num int) int {
	result := 0

	for i := 0; i <= num; i++ {
		result += i
	}

	return result
}

////////////////

Далее, в том числе и во второй части, мы снова обратимся к этому примеру

************************************************************************
Функции


Функция - то, чем вы уже пользуетесь постоянно
Если говорить просто, то функция - это кусок кода, которому вы скармливаете данные и он вам что-то выплевывает 

Вспомним пример с мариночкой. Там описана отдельная функция, которая принимает число типа int и возвращает тоже int 

////////////////

func countLetters(num int) int {
	result := 0

	for i := 0; i <= num; i++ {
		result += i
	}

	return result
}

////////////////

При работе с функцией ее нужно, во-первых, создать, и во-вторых, вызвать 

Создание функции начинается с ключевого слова func 
Затем придумываете имя функции и в круглых скобках перечисляете параметры 
Параметры указываются вместе с их типами 
В нашем случае функция countLetters имеет в качестве параметра num типа int 
Здесь мы не заморачиваем голову с типами, и в том числе потому, что при создании переменной i в цикле она по дефолту создается как int
Собственно, что делает функция - она возвращает сумму числе num, если оно больше нуля, либо возвращает ноль
Для возврата значения из функции используется оператор return 
return, кстати, не обязательно должен идти в конце тела функции - к примеру, где-то в середине может быть if, внутри которого может быть return 

После указания аргументов перечисляются типы возвращаемых значений
Особенностью go является то, что возвращаться может несколько значений сразу 
В этом случае возвращаемые значения берутся в скобки


Также нужно обратить внимание, что возвращаемые значения можно именовать:

////////////////

func countLetters(num int) (sum int) {
	sum = 0

	for i := 0; i <= num; i++ {
		sum += i
	}

	return sum
}

////////////////

Здесь переменная sum создается при объявлении возвращаемых значений
Такой подход вполне применим, что проще просто указывать типы возвращаемых значений

При работе с функциями нужно не только функцию создать, но и... не забыть вызвать ее
Происходит это достаточно просто - имя функции и в скобках передаваемые значения

Ах да, функция создается с параметрами, и вызывается с аргументами. Не путайте 

Если мы хотим использовать возвращаемое значение, то нужно присвоить его переменной 

Сейчас стоит сказать, что некоторые функции прописываются с заглавной буквы
fmt.Println()
Функция Println() вызывается из другого пакета
В рамках пакетов есть два вида функций:
1. Приватный функции (доступны только внутри пакета)
2. Публичные функции (отдаются наружу)

Если функция написана с большой буквы - значит, ее можно использовать в другом пакете 
Снова заглянем в будущее и используем слайс

////////////////

var lovers = []string{"Генерал Кастер", "Сальвадор Дали"}

func main() {
	listingLovers()
	
}

func listingLovers() {
	for _, value := range lovers {
		fmt.Println(value)
	}
}

////////////////

Как видим, функция успешно использует переменную, которую ей не передавали
Получает она ее благодаря механизму замыкания
Есть такое понятие, как область видимости
Когда мы объявляете переменную, она доступна далеко не везде
Следует различать глобальную область видимости, функциональную и блочную
Глобальная область видимости - это переменная lovers, она доступна везде в рамках пакета 
Функциональная область видимости - мы создаем переменную внутри функции, и она существует только там
Блочная область видимости - внутри блоков кода - for, if else, switch (в go это переменная, объявленная при создании цикла)

Замыкания в функции - это когда вы приходите к другу, у вас ничего нет, и вы шаритесь по местному холодильнику 

На собесах когда хотят что-то про это узнать, обычно имеют в виду узкий кейс:
Замыкание - это когда функция a возвращает функцию b, которая имеет доступ к переменным из тела функции a
К этой теме мы потом еще вернемся

************************************************************************
Указатели

Для начала попробуем вот такую штуку:

////////////////

func main() {
	newHusband := "Валера"
	fmt.Println(&newHusband) // 0xc0000140a0
}

////////////////

Что за... Где-то в жизни мы свернули не туда

Беря указатель, мы получаем не саму переменную, а адрес ячейки памяти, где она хранится (для сложных типов данных работает аналогичным образом)
Указатели используются повсеместно, и в основном в двух целях:
1. Экономия памяти (потом рассмотрим как можно передавать структуры и слайсы по указателю)
2. Сайд эффекты (т.е. побочные эффекты)

Когда мы прокидываем аргумент в функцию, происходит полное его копирование
Если мы хотим изменить изначальную переменную, то нужно передать указатель
Итак, говорим и показываем

////////////////

func main() {
	husband := "Валера"

	changeHusband(husband)
	
	fmt.Println(husband) // Валера
}

func changeHusband(name string) string {
	name = "Семка"

	return name
}

////////////////

Здесь женщина хочет сменить мужа, и чтобы кинуть понты ей нужна для этого отдельная тупая функция (айфон ради яблока)
GO язык хитрый, и IDE нам заботливо подчеркнет пару вещей и скажет, что здесь не получается сайд эффектов 

Если мы хотим изменить именно ту переменную, которую прокидываем, то нужен указатель

////////////////

func main() {
	husband := "Валера"

	changeHusband(&husband)
	
	fmt.Println(husband)
}

func changeHusband(name *string) string {
	*name = "Семка"

	return *name
}

////////////////

При работе с указателями нужно запомнить всего два символа - это амперсанд &, который берет указатель
    и * - это оператор разыменования, т.е. по адресу ячейки памяти от стучится к самому значению
Оператор разыменования указывается перед указанием типа, и дальше по коду где мы хотим использовать указатель

Кстати, есть еще такая запись - здесь в указании типа возвращаемого значения ставим звездочку, а в ретурне - нет 

////////////////

func changeHusband(name *string) *string {
	*name = "Семка"

	return name
}

////////////////

ЗАДАНИЕ:
1.6  Решаем задачки из папки basic

************************************************************************
Конец первой части 