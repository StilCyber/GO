Базовый практический курс по языку GO, третья часть

************************************************************************
Добро пожалость в завершающую часть трилогии
Вся она посвящена только одному - асинхронщина 

GO разрабатывался с той целью, чтобы забить ядра процессора
Ранее программы долбились в одно ядро 
А потом люди смекнули, что когда ядер стало много, чего они простаивают 
При помощи горутин go может достучаться до потоков операционной системы
И те уже в свою очередь напрягают процессор 

Вы уже наверно привыкли к тому, что код выполняется последовательно 
Теперь представьте, что мы может вызвать функцию, и она будет выполняться где-то в сторонке 
На самом деле вы уже сталкивались с горутинами - главная горутина это функция main 

Горутины объявляются ключевым словом go (goрутины, ха-ха)
Потестируем вот такой кусочек кода 

func main() {
    go printSomething()
    fmt.Println("Я устал, я ухожу")
}

func printSomething() {
    fmt.Println("Что-то печатаю...")
}

Здесь вообще без понятия, отработает ли функция printSomething()
Может быть да, и может и нет 

А теперь попробуем вот так

func main() {
    var str string
    go printSomething("Что-то печатаю...")
    fmt.Println("Я устал, я ухожу")
    fmt.Scan(&str)
    fmt.Println(str)
}

func printSomething(str string) {
    fmt.Println(str)
}

Здесь мы практически наверняка увидим результат работы функции 
А все потому, что пока мы ждем ввода, наша небольшая горутина успеет отработать 

У горутин может быть много и они выполняются параллельно друг другу
Горутина может либо выполняться, либо блокироваться 

Горутин может быть много, но сколько максимум может выполняться параллельно...
В целом, это зависит от от количества логических ядер процессора, который есть в вашем распоряжении

Узнать их количество можно разными способами - заглянуть в системный монитор ОС, глянуть характеристики проца... 
Но можно это сделать посредством самого go:
fmt.Println(runtime.NumCPU())

Логические ядра - это количество потоков NumCPU 

Можно ограничить число используемых горутин при помощи все того же пакета runtime
runtime.GOMAXPROCS(16)

Аргументом туда прокидывает максимально число горутин 
Если укажите больше, чем есть потоков процессора, то go будет брать по дефолту максимальное число логических ядер

Это все хорошо конечно, но нам надо подружить горутины друг с другом 
Делается это при помощи каналов 

Горутины могут общаться при помощи чтения и записи данных 
В этих целях создаются каналы между ними 
Давайте разберем на житейском примере

Вспомним знакомых нам персонажей - мариночку и светку 
Не забыли еще, сколько проблем было, когда просила подругу поделиться любовниками?
С горутинами это можно сделать адекватно 
Для синхронизации горутин между собой используются каналы
Каналы - отдельный тип данных
Они используются для чтения и записи данных 

Мариночка хочет отдохнуть вечером и немного расслабиться 
Для этого ей нужно вначале прошерстить список любовников 
И вот звонит ей светка и просит кем-нибудь сегодня поделиться
Будучи хорошей подругой, мариночка дает ей список любовников 
  и просит сообщить кого она выберет 
Затем мариночка будет искать уже из оставшихся любовников 

    import (
        "fmt"
        "math/rand"
    )

    func main() {
        // создаем канал
        ch := make(chan string)

        // создаем список любовников
        lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар", "Воин Орел"}

        // делаем заготовку для отфильтрованного слайса
        var accessLovers []string

        // вызываем горутину
        go changeLovers(lovers, ch)

        // читаем любовника из канала
        excludeLover := <-ch

        // проводим фильтрацию
        for _, value := range lovers {
            if value != excludeLover {
                accessLovers = append(accessLovers, value)
            }
        }

        // выводим доступных мариночке любовников
        fmt.Println(accessLovers)

    }

    func changeLovers(lovers []string, ch chan string) {
        // генерирует случайно целое число не более чем длина слайса
        num := rand.Intn(len(lovers))

        // запихиваем в канал
        ch <- lovers[num]
    }

Отлично, здесь мы создали канал, прокинули его в функцию и прочитали
Канал создается вот так
    ch := make(chan string)
chan означает канал - и дальше указываем тип данных канала

Если попробуем вывести канал в консоль, то получим... пар-парам, указатель
    fmt.Println(ch) // 0xc00002c0e0
При чтении и записи разыменовывать каналы не нужно - это уже заботливо сделано за нас 

Каналы создаются функцией make
Создание нилового канала при попытке использовать его по назначению вызовет дедлок горутин
    var ch chan string

    fatal error: all goroutines are asleep - deadlock!
    goroutine 1 [chan receive (nil chan)]

Мы не может оперировать непроинициализированными каналами
Инициализация каналов всегда происходит через make 
Вот такая запись будет корректной
    var ch chan string = make(chan string)

Канал прокидывается в горутину как аргумент функции
func changeLovers(lovers []string, ch chan string)

Внутри функции мы может в него что-то записать
    ch <- lovers[num]

И что собственно происходит в функции main 
    excludeLover := <-ch
Она будет ждать, пока не прочитает данные из канала

Необходимость чтения данных из канала блокирует горутину - она останавливается и ждет 
Поэтому это код отрабатывает корректно - горутина main не сможет завершиться раньше горутины changeLovers

Великолепно
Мы воспользовались двунаправленным небуферизированным каналом
Сейчас разберем что это такое 

Небуферизованный канал - тот канал, у которого емкость равна нулю 
Да, да, у каналов есть capacity 
И да, функция выглядит как и у слайсов cap()
В небуферизованный канал мы может только один раз закинуть данные, потом
   горутина-получатель эти данные получит, и можно повтрять эту схему 
А если у канала есть емкость, то можно несколько раз записывать подряд и в буфере сохранится несколько значений
Вот, в общем-то, и вся разница 

Буферизованные каналы разберем чуть позже, а перед этим посмотрим еще один кейс 

Для мариночки настал следующий вечер 
Надоедливая подруга сегодня ей не звонила 
Марина хочет в тишине и спокойствии позвонить одному из любовников 
Но, никак не может определиться 
Ей на помощь приходит магический шар 
Этому шару скармливается слайс с любовниками, и он рандомно выбирает имя 

    func main() {
        ch := make(chan []string)
        lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар", "Воин Орел"}

        go func() {
            lovers := <-ch
            num := rand.Intn(len(lovers))
            
            result := make([]string, 0, 1)
            result = append(result, lovers[num])

            ch <- result
        }()

    ch <- lovers

    result := <-ch
    fmt.Println(result)
    }

Работает это дело следующим образом
Сначала запускатеся горутина 
Затем она блокируется вот здесь 
    lovers := <-ch
И происходит это до тех пор, пока в канале что-то не окажется 
В функции main после вызова горутины происходит запись в канал
    ch <- lovers
Горутина, выбирающая любовника, просыпается, дело что нужно, и помещает данные в тот же канал
В это время горутина main отдыхает в ожидании этого момента
    result := <-ch

При организации каналов есть горутины-отправители и горутины-получатели (да, как на почте)
Двунаправленные каналы предполагают, что каждая из горутин может как отправлять данные, так и получать их 

Теперь о буферизованных горутинах 
Это такой зверь, который орудует пачками данных 
У каналов есть не только емкость, но и еще и, как ни странно, длина 

    func main() {
        ch := make(chan int, 5)

        fmt.Println(len(ch)) // 0
        fmt.Println(cap(ch)) // 5
    }

Здесь нужно обратить внимание, что в случае с каналами функция make принимает либо один, либо два аргумента
Т.е. у нас нет возможности задать длину, но зато может указать емкость 
И вот настал следующий вечер
Мариночка подумала, что ей нужно три любовника подряд 
И для этого нужен буферизированный канал
Если любовники будут повторяться... ничего страшного не произойдет 

    func main() {
        // создаем канал
        ch := make(chan string, 3)

        // переменная для вывода результата
        var lover string

        // создаем список любовников
        lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар", "Воин Орел"}

        // вызываем горутину
        go changeLovers(lovers, ch)

        for i := 0; i < cap(ch); i++ {
            lover = <-ch
            fmt.Println(lover)
        }

    }

    func changeLovers(lovers []string, ch chan string) {
        var num int

        for i := 0; i < cap(ch); i++ {
            num = rand.Intn(len(lovers))
            ch <- lovers[num]
        }
    }

Кстати, нет нужды полностью заполнять всю емкость 
    cap(ch) - 1
Если изменить условие в обоих циклах вот так, то просто выведется две записи 
Однако, если горутина-отправитель выплевывает три записи, а горутина-получатель ожидает четыре... ничем хорошим это не закончится 
Горутина-получатель будет ждать в состоянии блокировки, и... программа упадет 
    fatal error: all goroutines are asleep - deadlock!

Представьте ситуацию, когда хитрая горутина отправитель "забудет" отправить данные 
Даже лучше - перекроет канал 
Эта хитрая особа может воспользоваться специальной функцией - close()
А горутина-получатель будет ожидать столько порций, сколько есть емкости... 

    func changeLovers(lovers []string, ch chan string) {
        num := rand.Intn(len(lovers))
        ch <- lovers[num]

        close(ch)
    }

Что интересно, программа не упадет 
Если горутина-отправитель забудет что-то записать, то это будет крах 
А если канал будет аккуратно закрыт, как сейчас, то горутина-получатель заполнит недостающие куски zero value

Вообще, ей способ обезопаситься от произвола 
Горутина-получатель будет делать умную проверку 

    func main() {
        // создаем канал
        ch := make(chan string, 3)

        // создаем список любовников
        lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар", "Воин Орел"}

        // вызываем горутину
        go changeLovers(lovers, ch)

        for i := 0; i < cap(ch); i++ {
            if value, opened := <-ch; opened {
                fmt.Println(value)
            } else {
                fmt.Println("Произвол какой-то")
            }
        }
    }

    func changeLovers(lovers []string, ch chan string) {
        num := rand.Intn(len(lovers))
        ch <- lovers[num]

        close(ch)
    }

Мы может возвращать данные из канал и вторым параметром - true или false, что свидетельствует о состоянии канала 
Впрочем, если горутина-отправитель тупо недостат данные без закрытия канала, это все равно обвалит приложение
Так что, при работе с буферизированными каналами лучше всегда закрывать канал после передачи всех порциий - так безопасней 


Так, превосходно. Теперь разбере однонаправленные каналы
Как и следует из названия, это каналы в одном направлении (хе-хе)
Они либо читают, либо пишут 
chan<- канал только для отправки данных
<-chan - канал только для получения данных 

Рассмотрим пример типичного взаимодействия на сайте знакомств 
Женщина единственное, что делает - это читает однотипные сообщения
Это пример однонаправленного канала, в который можно только записывать данные

    func main() {
        ch := make(chan string, 10)

        messages(ch)

        for range cap(ch) {
            if value, opened := <-ch; opened {
                fmt.Println(value)
            }
        }

    }

    func messages(ch chan<- string) {
        defer close(ch)

        message := "Привет, как дела"

        for range cap(ch) {
            ch <- message
        }
    }

Кстати, каналы могут быть еще и возвращаемыми значениями
Но, чтобы не столкнуться с взаимной блокировкой горутин, эти действия 
   выносятся в другие горутины 

/////////////////////
Оператор select 

Представьте, что у нас есть несколько горутин, и нам нужно отловить первую, которая выполнится 
Вот у мариночки сегодня вечером дилемма 
Она и замуж хочет, и любовник нужен, и результаты анализов придут с минуты на минуту...
Если получится оперативно выцепить из своего хоровода кандидата в мужья, то она будет только его и доканывать 
Если же быстрее всего будет достучаться до одного из любовников, то так уж тому и быть 
И если придут результаты анализов - то ладно, лечение будет в приоритете 
В общем, в ход пустит первое что попадется

func main() {
	candidates := []string{"Игорек"}
	lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар", "Воин Орел"}
	venerealDiseases := []string{"Гепатит С", "Хламидиоз"}

	ch1 := make(chan string)
	ch2 := make(chan string)
	ch3 := make(chan string)


	go func() {
		time.Sleep(time.Second)
		ch1 <- candidates[0]
	}()

	go func() {
		time.Sleep(3 * time.Second)
		ch2 <- lovers[0]

	}()

	go func() {
		time.Sleep(15 * time.Second)
		ch3 <- venerealDiseases[0]
	}()


	select {
	case result := <-ch1:
		fmt.Println("Выбран муж: ", result)
	case result := <-ch2:
		fmt.Println("Выбран любовник: ", result)
	case result := <-ch3:
		fmt.Println("Получено заболевание: ", result)

	}

    fmt.Println("Выбор сделан")
}

Каждый кейс - это выполненная горутина 
Какая первой выполнится - то и будет 
Непоспевшие горутины рассматриваться не будут 
При вызове оператора select горутина main блокируется, и ждет пока не отработает один из case 
Можно еще прописать default - то, что отработает если ни одна из горутин по неким причинам не сможет записать данные в канал 

Сами горутины сляпаны достаточено просто - берет нулевой элемент слайса
time.Sleep - такая штука, которая стопорит выполнение горутины 
Когда код горутины начинает выполняться, то доходя до time.Sleep горутина погружается в сон... 
После выхода из спячки выполнение тела функции продолжается 
Аргументом в time.Sleep прокидывается количество секунд 
Тип данных аргумента кастомный, и чтобы все было правильно, берет встроенный time.Second - это 1 секунда, и помножаем на что-нибудь 

/////////////////////
wait group 

select это замечательно, но что если мы хотим дождаться выполнения всех горутин? 

Пользуясь концепцией мультивселенных, вообразим, что в другом мире мариночка совсем без тормозов и хочет чтобы выполнились все горутины 
И естественно, нужно блокировать горутину main пока не другие горутины не отработают 
Поможем ей на этот нелегком поприще 

Мы может объединить несколько горутин в группу 
Проведем мыслительный эксперимент 
Возьмем переменную-счетчик и запишем туда ноль 
В определенном месте внутри main блокируем горутину, и продолжаем только тогда, когда счетчик не будет равен, скажем, трем
Каждая отдельная горутина будет инкрементировать счетчик 
Удобно, не так ли? 
При таком подходе мы гибко может прописывать в каждой горутине, участвует ли она в увеличении счетчика 

Эта идея в go реализована в виде  wait group 
Создается группа горутин, main (или другая горутина) стопорится и ждет, пока все горутины из группы не отработают 

func main() {
	candidates := []string{"Игорек"}
	lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар", "Воин Орел"}
	venerealDiseases := []string{"Гепатит С", "Хламидиоз"}

	var wg sync.WaitGroup
	wg.Add(3)


	go func() {
		defer wg.Done()
		fmt.Println(candidates[0])
	}()

	go func() {
		defer wg.Done()
		fmt.Println(lovers[0])
	}()

	go func() {
		defer wg.Done()
		fmt.Println(venerealDiseases[0])
	}()

	wg.Wait()


	fmt.Println("Все данные определены")
}

Сразу обратите внимание, что каналов здесь нет - с каналами в горутине main нужно было бы не просто дождаться горутин, но и считать данные из каналов 
wait group - отдельный, самостоятельный механизм синхронизации горутин

Вначале создаем отдельную переменную с типом WaitGroup из пакета sync
var wg sync.WaitGroup

Затем вызываем у нее метод Add и указываем число горутин 
В каждой из горутин прописываем что она участвует в празднике жизни - wg.Done()
wg.Done() означает, что в счетчик, который лежит под капотом wait group, записывается +1 
Оператор defer позволяет инкрементировать значение после того как выполнится тело горутины

В самой горутине main указывает wg.Wait() обязательно после вызова всех горутин 
Когда выполнятся три горутины, main продолжит выполнение 

/////////////////////
Мьютексы 

Есть такие ситуации, когда много горутин обращаются к общему ресурсу 
И, это не всегда хорошо заканчивается 
Покажем на примере 
Генерал Кастер - востребованный любовник 
Однако, обращение разных женщин к нему является взаимоисключающ (вот такой он принципиальный)
Пускай у нас есть счетчик посещений генерала Кастера 
Каждая женщина будет ставить плюсик 
Посмотрим, что из этого выйдет 

func main() {
	counter := 0
	maxVisits := 100
	wg := sync.WaitGroup{}

	wg.Add(maxVisits)

	for range maxVisits {
		go addVisit(&counter, &wg)
	}

	wg.Wait()

	fmt.Println(counter)
}

func addVisit(counter *int, wg *sync.WaitGroup) {
	defer wg.Done()
	*counter++
}

Упс... в консоли какие-то разные данные каждый раз, а что происходит (попробуйте запустить раз 15-20)
Вроде же все нормально должно быть... 

Конкретно операция инкремента на самом деле состоит из трех действий:
oldCounter = counter
newCounter = oldCounter + 1
counter = newCounter 

Так, белиберда какая-то, давайте проясним 
Здесь берется из памяти изначальное значение, грузится в регистр процессора, и затем текущее значение в памяти перезаписывается 
      на то что высчитал процессор 
Проблема в том, что горутины работают вразнобой и каждый раз обращаются к непонятно чему - не факт, что следующая горутина получит обновленные данные 
    после работы своей предшественницы 
То есть что происходит - к примеру, у нас значение счетчика 0 
Первая горутина берет ноль и начинает что-то делать
Прибегает вторая горутина и берет тот же самый ноль 
В итоге обе горутины перезатирают одну из ту же ячейку памяти внося значение 1 

Называется эта хня "потерянное поколоние", ой нет, "потерянное обновление"

НАДО ПРЕКРАТИТЬ ДЕРБАНИТЬ ОБЩИЙ РЕСУРС

Это как тетки которые роются в помойном баке - если сразу все начнут дербанить то это же хаос какой-то (как пенсионерки когда раздают просрочку)
В каждый момент времени только одна тетка может там рыться 

func main() {
	counter := 0
	maxVisits := 100
	wg := sync.WaitGroup{}
	mutex := sync.Mutex{}
	
	wg.Add(maxVisits)

	for range maxVisits {
		go addVisit(&counter, &wg, &mutex)
	}

	wg.Wait()

	fmt.Println(counter)
}

func addVisit(counter *int, wg *sync.WaitGroup, mutex *sync.Mutex) {
	defer wg.Done()
	mutex.Lock()
	*counter++
	mutex.Unlock()
}

Прекрасно, теперь все окей 

Мьютекс - это структура, вот такая:

type Mutex struct {
    state int32
    sema  uint32
}

state - это состояние мьютекса 
Это 32-х битное число, в котором:
Бит 0 - если мьютекс залочен, то тут будет 1
Бит 1 - если какая-то горутина пробудилась от оков сна и пытается получить доступ к критичекой секции
Бит 2 - если мьютекс находится в режиме starvation то здесь будет 1
Биты 3 - 31 - эти биты отслеживают горутины, которые ожидают когда мьютекс разблокируется

Внутрянка нам не особо интересна, интерес вызывают методы 
Lock()
Unlock()

Тот кусок кода, который находится между Lock и Unlock называется критической секцией 
Фактически, бы блокируем не сам ресурс, а кусок кода, который что-то делает - по логике вещей работает с ресурсом 
Работает это тогда, когда мы некое число раз вызываем одну и ту же функцию в качестве горутины 

Когда женщина заходит к генералу Кастеру, вешается шторка, препятствующая проникновению других субъектов Lock()
Когда шторка спадает Unlock(), следующая горутина идет в ход 

Работа мьютексов плотно связана с состоянием горутин, их три:
1. Running (выполняется)
2. Waiting (ожидает)
3. Ready (все готово)

Когда одна горутина занята испонением критичекой секции, другая подоспевшая горутина попадает в состояние Waiting
Кстати, мьютекс не хранит в себе владельца блокировки, поэтому разлочить мьютекс возможно вообще где угодно, но конечно это не лучшая практика



