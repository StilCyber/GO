Базовый практический курс по языку GO, третья часть

************************************************************************
Добро пожалость в завершающую часть трилогии
Вся она посвящена только одному - асинхронщина 

GO разрабатывался с той целью, чтобы забить ядра процессора
Ранее программы долбились в одно ядро 
А потом люди смекнули, что когда ядер стало много, чего они простаивают 
При помощи горутин go может достучаться до потоков операционной системы
И те уже в свою очередь напрягают процессор 

Вы уже наверно привыкли к тому, что код выполняется последовательно 
Теперь представьте, что мы может вызвать функцию, и она будет выполняться где-то в сторонке 
На самом деле вы уже сталкивались с горутинами - главная горутина это функция main 

Горутины объявляются ключевым словом go (goрутины, ха-ха)
Потестируем вот такой кусочек кода 

func main() {
    go printSomething()
    fmt.Println("Я устал, я ухожу")
}

func printSomething() {
    fmt.Println("Что-то печатаю...")
}

Здесь вообще без понятия, отработает ли функция printSomething()
Может быть да, и может и нет 

А теперь попробуем вот так

func main() {
    var str string
    go printSomething("Что-то печатаю...")
    fmt.Println("Я устал, я ухожу")
    fmt.Scan(&str)
    fmt.Println(str)
}

func printSomething(str string) {
    fmt.Println(str)
}

Здесь мы практически наверняка увидим результат работы функции 
А все потому, что пока мы ждем ввода, наша небольшая горутина успеет отработать 

У горутин может быть много и они выполняются параллельно друг другу
Горутина может либо выполняться, либо блокироваться 

Горутин может быть много, но сколько максимум может выполняться параллельно...
В целом, это зависит от от количества логических ядер процессора, который есть в вашем распоряжении

Узнать их количество можно разными способами - заглянуть в системный монитор ОС, глянуть характеристики проца... 
Но можно это сделать посредством самого go:
fmt.Println(runtime.NumCPU())

Логические ядра - это количество потоков NumCPU 

Можно ограничить число используемых горутин при помощи все того же пакета runtime
runtime.GOMAXPROCS(16)

Аргументом туда прокидывает максимально число горутин 
Если укажите больше, чем есть потоков процессора, то go будет брать по дефолту максимальное число логических ядер

Это все хорошо конечно, но нам надо подружить горутины друг с другом 
Делается это при помощи каналов 

Горутины могут общаться при помощи чтения и записи данных 
В этих целях создаются каналы между ними 
Давайте разберем на житейском примере

Вспомним знакомых нам персонажей - мариночку и светку 
Не забыли еще, сколько проблем было, когда просила подругу поделиться любовниками?
С горутинами это можно сделать адекватно 
Для синхронизации горутин между собой используются каналы
Каналы - отдельный тип данных
Они используются для чтения и записи данных 

Мариночка хочет отдохнуть вечером и немного расслабиться 
Для этого ей нужно вначале прошестить список любовников 
И вот звонит ей светка и просит кем-нибудь сегодня поделиться
Будучи хорошей подругой, мариночка дает ей список любовников 
  и просит сообщить кого она выберет 
Затем мариночка будет искать уже из оставшихся любовников 

    import (
        "fmt"
        "math/rand"
    )

    func main() {
        // создаем канал
        ch := make(chan string)

        // создаем список любовников
        lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар", "Воин Орел"}

        // делаем заготовку для отфильтрованного слайса
        var accessLovers []string

        // вызываем горутину
        go changeLovers(lovers, ch)

        // читаем любовника из канала
        excludeLover := <-ch

        // проводим фильтрацию
        for _, value := range lovers {
            if value != excludeLover {
                accessLovers = append(accessLovers, value)
            }
        }

        // выводим доступных мариночке любовников
        fmt.Println(accessLovers)

    }

    func changeLovers(lovers []string, ch chan string) {
        // генерирует случайно целое число не более чем длина слайса
        num := rand.Intn(len(lovers))

        // запихиваем в канал
        ch <- lovers[num]
    }

Отлично, здесь мы создали канал, прокинули его в функцию и прочитали
Канал создается вот так
    ch := make(chan string)
chan означает канал - и дальше указываем тип данных канала

Если попробуем вывести канал в консоль, то получим... пар-парам, указатель
    fmt.Println(ch) // 0xc00002c0e0
При чтении и записи разыменовывать каналы не нужно - это уже заботливо сделано за нас 

Каналы создаются функцией make
Создание нилового канала при попытке использовать его по назначению вызовет дедлок горутин
    var ch chan string

    fatal error: all goroutines are asleep - deadlock!
    goroutine 1 [chan receive (nil chan)]

Мы не может оперировать непроинициализированными каналами
Инициализация каналов всегда происходит через make 
Вот такая запись будет корректной
    var ch chan string = make(chan string)

Канал прокидывается в горутину как аргумент функции
func changeLovers(lovers []string, ch chan string)

Внутри функции мы может в него что-то записать
    ch <- lovers[num]

И что собственно происходит в функции main 
    excludeLover := <-ch
Она будет ждать, пока не прочитает данные из канала

Необходимость чтения данных из канала блокирует горутину - она останавливается и ждет 
Поэтому это код отрабатывает корректно - горутина main не сможет завершиться раньше горутины changeLovers

Великолепно
Мы воспользовались двунаправленным небуферизированным каналом
Сейчас разберем что это такое 

Небуферизованный канал - тот канал, у которого емкость равна нулю 
Да, да, у каналов есть capacity 
И да, функция выглядит как и у слайсов cap()
В небуферизованный канал мы может только один раз закинуть данные, потом
   горутина-получатель эти данные получит, и можно повтрять эту схему 
А если у канала есть емкость, то можно несколько раз записывать подряд и в буфере сохранится несколько значений
Вот, в общем-то, и вся разница 

Буферизованные каналы разберем чуть позже, а перед этим посмотрим еще один кейс 

Для мариночки настал следующий вечер 
Надоедливая подруга сегодня ей не звонила 
Марина хочет в тишине и спокойствии позвонить одному из любовников 
Но, никак не может определиться 
Ей на помощь приходит магический шар 
Этому шару скармливается слайс с любовниками, и он рандомно выбирает имя 

    func main() {
        ch := make(chan []string)
        lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар", "Воин Орел"}

        go func() {
            lovers := <-ch
            num := rand.Intn(len(lovers))
            
            result := make([]string, 0, 1)
            result = append(result, lovers[num])

            ch <- result
        }()

    ch <- lovers

    result := <-ch
    fmt.Println(result)
    }

Работает это дело следующим образом
Сначала запускатеся горутина 
Затем она блокируется вот здесь 
    lovers := <-ch
И происходит это до тех пор, пока в канале что-то не окажется 
В функции main после вызова горутины происходит запись в канал
    ch <- lovers
Горутина, выбирающая любовника, просыпается, дело что нужно, и помещает данные в тот же канал
В это время горутина main отдыхает в ожидании этого момента
    result := <-ch

При организации каналов есть горутины-отправители и горутины-получатели (да, как на почте)
Двунаправленные каналы предполагают, что каждая из горутин может как отправлять данные, так и получать их 

Теперь о буферизованных горутинах 
Это такой зверь, который орудует пачками данных 
У каналов есть не только емкость, но и еще и, как ни странно, длина 

    func main() {
        ch := make(chan int, 5)

        fmt.Println(len(ch)) // 0
        fmt.Println(cap(ch)) // 5
    }

Здесь нужно обратить внимание, что в случае с каналами функция make принимает либо один, либо два аргумента
Т.е. у нас нет возможности задать длину, но зато может указать емкость 
И вот настал следующий вечер
Мариночка подумала, что ей нужно три любовника подряд 
И для этого нужен буферизированный канал
Если любовники будут повторяться... ничего страшного не произойдет 

    func main() {
        // создаем канал
        ch := make(chan string, 3)

        // переменная для вывода результата
        var lover string

        // создаем список любовников
        lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар", "Воин Орел"}

        // вызываем горутину
        go changeLovers(lovers, ch)

        for i := 0; i < cap(ch); i++ {
            lover = <-ch
            fmt.Println(lover)
        }

    }

    func changeLovers(lovers []string, ch chan string) {
        var num int

        for i := 0; i < cap(ch); i++ {
            num = rand.Intn(len(lovers))
            ch <- lovers[num]
        }
    }

Кстати, нет нужды полностью заполнять всю емкость 
    cap(ch) - 1
Если изменить условие в обоих циклах вот так, то просто выведется две записи 
Однако, если горутина-отправитель выплевывает три записи, а горутина-получатель ожидает четыре... ничем хорошим это не закончится 
Горутина-получатель будет ждать в состоянии блокировки, и... программа упадет 
    fatal error: all goroutines are asleep - deadlock!

Представьте ситуацию, когда хитрая горутина отправитель "забудет" отправить данные 
Даже лучше - перекроет канал 
Эта хитрая особа может воспользоваться специальной функцией - close()
А горутина-получатель будет ожидать столько порций, сколько есть емкости... 

    func changeLovers(lovers []string, ch chan string) {
        num := rand.Intn(len(lovers))
        ch <- lovers[num]

        close(ch)
    }

Что интересно, программа не упадет 
Если горутина-отправитель забудет что-то записать, то это будет крах 
А если канал будет аккуратно закрыт, как сейчас, то горутина-получатель заполнит недостающие куски zero value

Вообще, ей способ обезопаситься от произвола 
Горутина-получатель будет делать умную проверку 

    func main() {
        // создаем канал
        ch := make(chan string, 3)

        // создаем список любовников
        lovers := []string{"Генерал Кастер", "Эрнан Кортес", "Глеб Бокий", "Воин Ягуар", "Воин Орел"}

        // вызываем горутину
        go changeLovers(lovers, ch)

        for i := 0; i < cap(ch); i++ {
            if value, opened := <-ch; opened {
                fmt.Println(value)
            } else {
                fmt.Println("Произвол какой-то")
            }
        }
    }

    func changeLovers(lovers []string, ch chan string) {
        num := rand.Intn(len(lovers))
        ch <- lovers[num]

        close(ch)
    }

Мы может возвращать данные из канал и вторым параметром - true или false, что свидетельствует о состоянии канала 
Впрочем, если горутина-отправитель тупо недостат данные без закрытия канала, это все равно обвалит приложение
Так что, при работе с буферизированными каналами лучше всегда закрывать канал после передачи всех порциий - так безопасней 


Так, превосходно. Теперь разбере однонаправленные каналы
Как и следует из названия, это каналы в одном направлении (хе-хе)
Они либо читают, либо пишут 
chan<- канал только для отправки данных
<-chan - канал только для получения данных 

Рассмотрим пример типичного взаимодействия на сайте знакомств 
Женщина единственное, что делает - это читает однотипные сообщения
Это пример однонаправленного канала, в который можно только записывать данные

    func main() {
        ch := make(chan string, 10)

        messages(ch)

        for range cap(ch) {
            if value, opened := <-ch; opened {
                fmt.Println(value)
            }
        }

    }

    func messages(ch chan<- string) {
        defer close(ch)

        message := "Привет, как дела"

        for range cap(ch) {
            ch <- message
        }
    }

Кстати, каналы могут быть еще и возвращаемыми значениями
Но, чтобы не столкнуться с взаимной блокировкой горутин, эти действия 
   выносятся в другие горутины 

