GO в вопросах и ответах 


Планировщик

1. Планировщик в GO - кооперативный или вытесняющий?

Верный ответ - кооперативный с элементом вытеснения (короче ни тот ни другой)

Если исполняемая горутина (в статусе running) маринуется дольше 10 ms, 
то системный монитор планировщинка (sysmon) вешает на горутину флаг stackguard в значение stackPreempt
Исполняемая горутина сама проверяет наличие этого флага в следующие моменты:
- вызов функций
- блокирующие операции (сисколы, тайм слип, чтение из канала, запись в канал и др.)

В операционных системах планировщик вытесняющий - он сам решает когда снимать тред с ядра 
В go планировщик использует "мягкое вытеснение" - горутина при наличии флага сама сваливает

Недостаток такого подхода в том, что если горутина незахочет самовыпиливаться, то ее никто это сделать не заставит
В версии языка 1.14 этот момент решили пофиксить, добавим элемент вытеснения
Прицепили вызов сигнала ОС каждый 10 ms, который может выкинуть горутину куда подальше 

2. Что происходит при запуске программы go?

- запускается пакет runtime (который в том числе и управляет планировщиком)
- пакет runtime инициализирует P для работы горутин
их будет столько, сколько потоков ОС 

Есть парочка интересных функций:
runtime.NumCPU() - показывает общее число потоков процессора 

runtime.GOMAXPROCS() - если передаем 0, то возвращает количество P 
   если передаем другое число - то устанавливается максимальное количество P 

Просто посмотреть количество P (по сути аналогичный вывод как и у NumCPU)
runtime.GOMAXPROCS(0)

Установить максимальное количество P (к примеру 5)
runtime.GOMAXPROCS(5)

Не дайте GOMAXPROCS себя обмануть - GOMAXPROCS(5) вернет сначала предыдущее число P, и попутно внесет коррективы

///
Атомарные операции - примитивы синхронизации, запрещающие комплиятору и процессору переупорядочивать код 
Внутри атомарных операций используются барьеры памяти, что недопускает data race в программах 